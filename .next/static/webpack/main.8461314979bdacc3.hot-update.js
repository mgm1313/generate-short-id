"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar _s2 = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initNext = initNext;\nexports.render = render;\nexports.renderError = renderError;\nexports.emitter = exports.router = exports.version = void 0;\n__webpack_require__(/*! @next/polyfill-module */ \"./node_modules/@next/polyfill-module/dist/polyfill-module.js\");\nvar _react = _interopRequireDefault1(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _reactDom = _interopRequireDefault1(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _styledJsx = __webpack_require__(/*! styled-jsx */ \"./node_modules/styled-jsx/index.js\");\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interopRequireDefault1(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interopRequireDefault1(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interopRequireDefault1(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _vitals = __webpack_require__(/*! ./vitals */ \"./node_modules/next/dist/client/vitals.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard1(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _objectSpread(target) {\n    var _arguments = arguments, _loop = function(i) {\n        var source = _arguments[i] != null ? _arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    };\n    for(var i = 1; i < arguments.length; i++)_loop(i);\n    return target;\n}\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar version = \"11.1.3-canary.104\";\nexports.version = version;\nvar looseToArray = function(input) {\n    return [].slice.call(input);\n};\nvar hydrateProps = data.props, hydrateErr = data.err, page = data.page, query = data.query, buildId = data.buildId, assetPrefix = data.assetPrefix, runtimeConfig = data.runtimeConfig, dynamicIds = data.dynamicIds, isFallback = data.isFallback, locale = data.locale, locales = data.locales, domainLocales = data.domainLocales, isPreview = data.isPreview;\nvar defaultLocale = data.defaultLocale;\nvar prefix = assetPrefix || '';\n// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n// So, this is how we do it in the client side at runtime\n__webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n;\n// Initialize next/config with the environment configuration\n(0, _runtimeConfig).setConfig({\n    serverRuntimeConfig: {\n    },\n    publicRuntimeConfig: runtimeConfig || {\n    }\n});\nvar asPath = (0, _utils).getURL();\n// make sure not to attempt stripping basePath for 404s\nif ((0, _router).hasBasePath(asPath)) {\n    asPath = (0, _router).delBasePath(asPath);\n}\nif (false) { var detectedDomain, localePathResult, parsedAs, formatUrl, parseRelativeUrl, detectDomainLocale, normalizeLocalePath; }\nif (data.scriptLoader) {\n    var initScriptLoader = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\").initScriptLoader;\n    initScriptLoader(data.scriptLoader);\n}\nvar pageLoader = new _pageLoader.default(buildId, prefix);\nvar register = function(param) {\n    var _param = _slicedToArray(param, 2), r = _param[0], f = _param[1];\n    return pageLoader.routeLoader.onEntrypoint(r, f);\n};\nif (window.__NEXT_P) {\n    // Defer page registration for another tick. This will increase the overall\n    // latency in hydrating the page, but reduce the total blocking time.\n    window.__NEXT_P.map(function(p) {\n        return setTimeout(function() {\n            return register(p);\n        }, 0);\n    });\n}\nwindow.__NEXT_P = [];\nwindow.__NEXT_P.push = register;\nvar headManager = (0, _headManager).default();\nvar appElement = document.getElementById('__next');\nvar lastRenderReject;\nvar webpackHMR;\nvar router;\nexports.router = router;\nvar CachedApp, onPerfEntry;\nheadManager.getIsSsr = function() {\n    return router.isSsr;\n};\nvar Container = /*#__PURE__*/ function(_Component) {\n    _inherits(Container, _Component);\n    function Container() {\n        _classCallCheck(this, Container);\n        return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));\n    }\n    _createClass(Container, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(componentErr, info) {\n                this.props.fn(componentErr, info);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.scrollToHash();\n                // We need to replace the router state if:\n                // - the page was (auto) exported and has a query string or search (hash)\n                // - it was auto exported and is a dynamic route (to provide params)\n                // - if it is a client-side skeleton (fallback render)\n                if (router.isSsr && // the asPath unexpectedly e.g. adding basePath when\n                // it wasn't originally present\n                page !== '/404' && page !== '/_error' && (isFallback || data.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false) || hydrateProps && hydrateProps.__N_SSG && (location.search || false))) {\n                    // update query on mount for exported pages\n                    router.replace(router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                        // @ts-ignore\n                        // WARNING: `_h` is an internal option for handing Next.js\n                        // client-side hydration. Your app should _never_ use this property.\n                        // It may change at any time without notice.\n                        _h: 1,\n                        // Fallback pages must trigger the data fetch, so the transition is\n                        // not shallow.\n                        // Other pages (strictly updating query) happens shallowly, as data\n                        // requirements would already be present.\n                        shallow: !isFallback\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.scrollToHash();\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash() {\n                var hash = location.hash;\n                hash = hash && hash.substring(1);\n                if (!hash) return;\n                var el = document.getElementById(hash);\n                if (!el) return;\n                // If we call scrollIntoView() in here without a setTimeout\n                // it won't scroll properly.\n                setTimeout(function() {\n                    return el.scrollIntoView();\n                }, 0);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (false) {} else {\n                    var ReactDevOverlay = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").ReactDevOverlay;\n                    return(/*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children));\n                }\n            }\n        }\n    ]);\n    return Container;\n}(_react.default.Component);\nvar emitter = (0, _mitt).default();\nexports.emitter = emitter;\nvar CachedComponent;\nfunction _initNext() {\n    _initNext = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(param1) {\n        var opts = param1 === void 0 ? {\n        } : param1;\n        var initialErr, appEntrypoint, app, mod, exportedReportWebVitals, pageEntrypoint, isValidElementType, getNodeError, renderCtx;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    // This makes sure this specific lines are removed in production\n                    if (true) {\n                        webpackHMR = opts.webpackHMR;\n                    }\n                    initialErr = hydrateErr;\n                    _ctx.prev = 2;\n                    _ctx.next = 5;\n                    return pageLoader.routeLoader.whenEntrypoint('/_app');\n                case 5:\n                    appEntrypoint = _ctx.sent;\n                    if (!('error' in appEntrypoint)) {\n                        _ctx.next = 8;\n                        break;\n                    }\n                    throw appEntrypoint.error;\n                case 8:\n                    var ref;\n                    ref = appEntrypoint, app = ref.component, mod = ref.exports, ref;\n                    CachedApp = app;\n                    exportedReportWebVitals = mod && mod.reportWebVitals;\n                    onPerfEntry = function(param) {\n                        var id = param.id, name = param.name, startTime = param.startTime, value = param.value, duration = param.duration, entryType = param.entryType, entries = param.entries;\n                        // Combines timestamp with random number for unique ID\n                        var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9000000000000 - 1)) + 1000000000000);\n                        var perfStartEntry;\n                        if (entries && entries.length) {\n                            perfStartEntry = entries[0].startTime;\n                        }\n                        var webVitals = {\n                            id: id || uniqueID,\n                            name: name,\n                            startTime: startTime || perfStartEntry,\n                            value: value == null ? duration : value,\n                            label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                        };\n                        exportedReportWebVitals === null || exportedReportWebVitals === void 0 ? void 0 : exportedReportWebVitals(webVitals);\n                        (0, _vitals).trackWebVitalMetric(webVitals);\n                    };\n                    if (// error, so we need to skip waiting for the entrypoint.\n                    !( true && hydrateErr)) {\n                        _ctx.next = 16;\n                        break;\n                    }\n                    _ctx.t0 = {\n                        error: hydrateErr\n                    };\n                    _ctx.next = 19;\n                    break;\n                case 16:\n                    _ctx.next = 18;\n                    return pageLoader.routeLoader.whenEntrypoint(page);\n                case 18:\n                    _ctx.t0 = _ctx.sent;\n                case 19:\n                    pageEntrypoint = _ctx.t0;\n                    if (!('error' in pageEntrypoint)) {\n                        _ctx.next = 22;\n                        break;\n                    }\n                    throw pageEntrypoint.error;\n                case 22:\n                    CachedComponent = pageEntrypoint.component;\n                    if (false) {}\n                    isValidElementType = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType;\n                    if (isValidElementType(CachedComponent)) {\n                        _ctx.next = 27;\n                        break;\n                    }\n                    throw new Error(\"The default export is not a React Component in page: \\\"\".concat(page, \"\\\"\"));\n                case 27:\n                    _ctx.next = 32;\n                    break;\n                case 29:\n                    _ctx.prev = 29;\n                    _ctx.t1 = _ctx[\"catch\"](2);\n                    // This catches errors like throwing in the top level of a module\n                    initialErr = (0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + '');\n                case 32:\n                    if (true) {\n                        getNodeError = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").getNodeError;\n                        // Server-side runtime errors need to be re-thrown on the client-side so\n                        // that the overlay is rendered.\n                        if (initialErr) {\n                            if (initialErr === hydrateErr) {\n                                setTimeout(function() {\n                                    var error;\n                                    try {\n                                        // Generate a new error object. We `throw` it because some browsers\n                                        // will set the `stack` when thrown, and we want to ensure ours is\n                                        // not overridden when we re-throw it below.\n                                        throw new Error(initialErr.message);\n                                    } catch (e) {\n                                        error = e;\n                                    }\n                                    error.name = initialErr.name;\n                                    error.stack = initialErr.stack;\n                                    // Errors from the middleware are reported as client-side errors\n                                    // since the middleware is compiled using the client compiler\n                                    if ('middleware' in hydrateErr) {\n                                        throw error;\n                                    }\n                                    var node = getNodeError(error);\n                                    throw node;\n                                });\n                            } else {\n                                setTimeout(function() {\n                                    throw initialErr;\n                                });\n                            }\n                        }\n                    }\n                    if (!window.__NEXT_PRELOADREADY) {\n                        _ctx.next = 36;\n                        break;\n                    }\n                    _ctx.next = 36;\n                    return window.__NEXT_PRELOADREADY(dynamicIds);\n                case 36:\n                    exports.router = router = (0, _router1).createRouter(page, query, asPath, {\n                        initialProps: hydrateProps,\n                        pageLoader: pageLoader,\n                        App: CachedApp,\n                        Component: CachedComponent,\n                        wrapApp: wrapApp,\n                        err: initialErr,\n                        isFallback: Boolean(isFallback),\n                        subscription: function(info, App, scroll) {\n                            return render(Object.assign({\n                            }, info, {\n                                App: App,\n                                scroll: scroll\n                            }));\n                        },\n                        locale: locale,\n                        locales: locales,\n                        defaultLocale: defaultLocale,\n                        domainLocales: domainLocales,\n                        isPreview: isPreview\n                    });\n                    renderCtx = {\n                        App: CachedApp,\n                        initial: true,\n                        Component: CachedComponent,\n                        props: hydrateProps,\n                        err: initialErr\n                    };\n                    if (true) {\n                        _ctx.next = 43;\n                        break;\n                    }\n                    render(renderCtx);\n                    return _ctx.abrupt(\"return\", emitter);\n                case 43:\n                    return _ctx.abrupt(\"return\", {\n                        emitter: emitter,\n                        renderCtx: renderCtx\n                    });\n                case 44:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                2,\n                29\n            ]\n        ]);\n    }));\n    return _initNext.apply(this, arguments);\n}\nfunction initNext() {\n    return _initNext.apply(this, arguments);\n}\nfunction _render() {\n    _render = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(renderingProps) {\n        var renderErr;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (!renderingProps.err) {\n                        _ctx.next = 4;\n                        break;\n                    }\n                    _ctx.next = 3;\n                    return renderError(renderingProps);\n                case 3:\n                    return _ctx.abrupt(\"return\");\n                case 4:\n                    _ctx.prev = 4;\n                    _ctx.next = 7;\n                    return doRender(renderingProps);\n                case 7:\n                    _ctx.next = 17;\n                    break;\n                case 9:\n                    _ctx.prev = 9;\n                    _ctx.t0 = _ctx[\"catch\"](4);\n                    renderErr = _instanceof(_ctx.t0, Error) ? _ctx.t0 : new Error(_ctx.t0 + '');\n                    if (!renderErr.cancelled) {\n                        _ctx.next = 14;\n                        break;\n                    }\n                    throw renderErr;\n                case 14:\n                    if (true) {\n                        // Ensure this error is displayed in the overlay in development\n                        setTimeout(function() {\n                            throw renderErr;\n                        });\n                    }\n                    _ctx.next = 17;\n                    return renderError(_objectSpread({\n                    }, renderingProps, {\n                        err: renderErr\n                    }));\n                case 17:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                4,\n                9\n            ]\n        ]);\n    }));\n    return _render.apply(this, arguments);\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction renderError(renderErrorProps) {\n    var App = renderErrorProps.App, err = renderErrorProps.err;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: function() {\n                return null;\n            },\n            props: {\n            },\n            Component: function() {\n                return null;\n            },\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage('/_error').then(function(param) {\n        var ErrorComponent = param.page, styleSheets = param.styleSheets;\n        return (lastAppProps === null || lastAppProps === void 0 ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(function() {\n            return _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"));\n        }).then(function(m) {\n            return {\n                ErrorComponent: m.default,\n                styleSheets: []\n            };\n        }) : {\n            ErrorComponent: ErrorComponent,\n            styleSheets: styleSheets\n        };\n    }).then(function(param) {\n        var ErrorComponent = param.ErrorComponent, styleSheets = param.styleSheets;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        var AppTree = wrapApp(App);\n        var appCtx = {\n            Component: ErrorComponent,\n            AppTree: AppTree,\n            router: router,\n            ctx: {\n                err: err,\n                pathname: page,\n                query: query,\n                asPath: asPath,\n                AppTree: AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function(initProps) {\n            return doRender(_objectSpread({\n            }, renderErrorProps, {\n                err: err,\n                Component: ErrorComponent,\n                styleSheets: styleSheets,\n                props: initProps\n            }));\n        });\n    });\n}\nvar reactRoot = null;\n// On initial render a hydrate should always happen\nvar shouldHydrate = true;\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark('beforeRender');\n    }\n    var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (false) {} else {\n        // The check for `.hydrate` is there to support React alternatives like preact\n        if (shouldHydrate) {\n            _reactDom.default.hydrate(reactEl, domEl);\n            shouldHydrate = false;\n        } else {\n            _reactDom.default.render(reactEl, domEl);\n        }\n    }\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterHydrate') // mark end of hydration\n    ;\n    performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');\n    performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterRender') // mark end of render\n    ;\n    var navStartEntries = performance.getEntriesByName('routeChange', 'mark');\n    if (!navStartEntries.length) return;\n    performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');\n    performance.measure('Next.js-render', 'beforeRender', 'afterRender');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);\n        performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        'Next.js-route-change-to-render',\n        'Next.js-render'\n    ].forEach(function(measure) {\n        return performance.clearMeasures(measure);\n    });\n}\nfunction clearMarks() {\n    [\n        'beforeRender',\n        'afterHydrate',\n        'afterRender',\n        'routeChange'\n    ].forEach(function(mark) {\n        return performance.clearMarks(mark);\n    });\n}\nfunction AppContainer(param) {\n    var children = param.children;\n    return(/*#__PURE__*/ _react.default.createElement(Container, {\n        fn: function(error) {\n            return renderError({\n                App: CachedApp,\n                err: error\n            }).catch(function(err) {\n                return console.error('Error rendering page: ', err);\n            });\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router1).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_styledJsx.StyleRegistry, null, children)))));\n}\n_c = AppContainer;\nvar wrapApp = function(App) {\n    return function(wrappedAppProps) {\n        var appProps = _objectSpread({\n        }, wrappedAppProps, {\n            Component: CachedComponent,\n            err: hydrateErr,\n            router: router\n        });\n        return(/*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n        }, appProps))));\n    };\n};\nvar lastAppProps;\nfunction doRender(input) {\n    var onStart = // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // unless we're in production:\n        'development' !== 'production') {\n            return false;\n        }\n        var currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        var currentHrefs = new Set(currentStyleTags.map(function(tag) {\n            return tag.getAttribute('data-n-href');\n        }));\n        var noscript = document.querySelector('noscript[data-n-css]');\n        var nonce = noscript === null || noscript === void 0 ? void 0 : noscript.getAttribute('data-n-css');\n        styleSheets.forEach(function(param) {\n            var href = param.href, text = param.text;\n            if (!currentHrefs.has(href)) {\n                var styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    };\n    var onHeadCommit = function onHeadCommit() {\n        if (// unless we're in production:\n        false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n        if (input.scroll) {\n            window.scrollTo(input.scroll.x, input.scroll.y);\n        }\n    };\n    var onRootCommit = function onRootCommit() {\n        resolvePromise();\n    };\n    var App = input.App, Component = input.Component, props = input.props, err = input.err;\n    var styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    var appProps = _objectSpread({\n    }, props, {\n        Component: Component,\n        err: err,\n        router: router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    var canceled = false;\n    var resolvePromise;\n    var renderPromise = new Promise(function(resolve, reject) {\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = function() {\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = function() {\n            canceled = true;\n            lastRenderReject = null;\n            var error = new Error('Cancel rendering route');\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    onStart();\n    var elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n    }, appProps)), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, function(callback) {\n        /*#__PURE__*/ return _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem);\n    });\n    return renderPromise;\n}\nfunction Root(param) {\n    var callbacks = param.callbacks, children = param.children;\n    _s2();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(function() {\n        return callbacks.forEach(function(callback) {\n            return callback();\n        });\n    }, [\n        callbacks\n    ]);\n    if (undefined) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        _react.default.useEffect(function() {\n            window.__NEXT_HYDRATED = true;\n            if (window.__NEXT_HYDRATED_CB) {\n                window.__NEXT_HYDRATED_CB();\n            }\n        }, []);\n    }\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(function() {\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c1 = Root;\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    var callback = param.callback;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(function() {\n        return callback();\n    }, [\n        callback\n    ]);\n    return null;\n} //# sourceMappingURL=index.js.map\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Head;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Root\");\n$RefreshReg$(_c2, \"Head\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFLFFBQVE7QUFDM0JGLGNBQWMsR0FBR0csTUFBTTtBQUN2QkgsbUJBQW1CLEdBQUdJLFdBQVc7QUFDakNKLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDM0RRLG1CQUFPLENBQUMsMkZBQXVCO0FBQy9CLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHQyx1QkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyw0Q0FBTztBQUNuRCxHQUFHLENBQUNHLFNBQVMsR0FBR0QsdUJBQXNCLENBQUNGLG1CQUFPLENBQUMsb0RBQVc7QUFDMUQsR0FBRyxDQUFDSSxVQUFVLEdBQUdKLG1CQUFPLENBQUMsc0RBQVk7QUFDckMsR0FBRyxDQUFDSyxtQkFBbUIsR0FBR0wsbUJBQU8sQ0FBQyx1R0FBb0M7QUFDdEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdKLHVCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFvQjtBQUMvRCxHQUFHLENBQUNPLGNBQWMsR0FBR1AsbUJBQU8sQ0FBQywyRkFBOEI7QUFDM0QsR0FBRyxDQUFDUSxPQUFPLEdBQUdSLG1CQUFPLENBQUMseUZBQTZCO0FBQ25ELEdBQUcsQ0FBQ1MsVUFBVSxHQUFHVCxtQkFBTyxDQUFDLDZHQUF1QztBQUNoRSxHQUFHLENBQUNVLFlBQVksR0FBR1YsbUJBQU8sQ0FBQyxvSEFBd0M7QUFDbkUsR0FBRyxDQUFDVyxjQUFjLEdBQUdYLG1C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QUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ0wsTUFBTSxDQUFDeUIsUUFBUTtBQUNuQixDQUFDO0lBdkJReUksSUFBSTtNQUFKQSxJQUFJO0FBd0JiLEVBQW1FO0FBQ25FLEVBQXlEO1NBQ2hETCxJQUFJLENBQUMsS0FBYSxFQUFFLENBQUM7UUFBZEMsUUFBUSxHQUFWLEtBQWEsQ0FBWEEsUUFBUTs7SUFDcEIsRUFBaUU7SUFDakUsRUFBdUM7SUFDdkN2UyxNQUFNLENBQUMrQyxPQUFPLENBQUNnUSxlQUFlLENBQUMsUUFBUTtRQUFKUixNQUFNLENBQU5BLFFBQVE7T0FDekMsQ0FBQztRQUNDQSxRQUFRO0lBQ1osQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJO0FBQ2YsQ0FBQyxDQUVnQztJQVZ4QkQsSUFBSTtNQUFKQSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzPzQ2Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmluaXROZXh0ID0gaW5pdE5leHQ7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMucmVuZGVyRXJyb3IgPSByZW5kZXJFcnJvcjtcbmV4cG9ydHMuZW1pdHRlciA9IGV4cG9ydHMucm91dGVyID0gZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xucmVxdWlyZShcIkBuZXh0L3BvbHlmaWxsLW1vZHVsZVwiKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfc3R5bGVkSnN4ID0gcmVxdWlyZShcInN0eWxlZC1qc3hcIik7XG52YXIgX2hlYWRNYW5hZ2VyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0XCIpO1xudmFyIF9taXR0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9taXR0XCIpKTtcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3J1bnRpbWVDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZ1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbnZhciBfcG9ydGFsID0gcmVxdWlyZShcIi4vcG9ydGFsXCIpO1xudmFyIF9oZWFkTWFuYWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyXCIpKTtcbnZhciBfcGFnZUxvYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFnZS1sb2FkZXJcIikpO1xudmFyIF9wZXJmb3JtYW5jZVJlbGF5ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpO1xudmFyIF9yb3V0ZUFubm91bmNlciA9IHJlcXVpcmUoXCIuL3JvdXRlLWFubm91bmNlclwiKTtcbnZhciBfcm91dGVyMSA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX3ZpdGFscyA9IHJlcXVpcmUoXCIuL3ZpdGFsc1wiKTtcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge1xuICAgICAgICB9O1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKS50ZXh0Q29udGVudCk7XG53aW5kb3cuX19ORVhUX0RBVEFfXyA9IGRhdGE7XG5jb25zdCB2ZXJzaW9uID0gXCIxMS4xLjMtY2FuYXJ5LjEwNFwiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IGxvb3NlVG9BcnJheSA9IChpbnB1dCk9PltdLnNsaWNlLmNhbGwoaW5wdXQpXG47XG5jb25zdCB7IHByb3BzOiBoeWRyYXRlUHJvcHMgLCBlcnI6IGh5ZHJhdGVFcnIgLCBwYWdlICwgcXVlcnkgLCBidWlsZElkICwgYXNzZXRQcmVmaXggLCBydW50aW1lQ29uZmlnICwgZHluYW1pY0lkcyAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAsICB9ID0gZGF0YTtcbmxldCB7IGRlZmF1bHRMb2NhbGUgIH0gPSBkYXRhO1xuY29uc3QgcHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJyc7XG4vLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4vLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7cHJlZml4fS9fbmV4dC9gIC8vZXNsaW50LWRpc2FibGUtbGluZVxuO1xuLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4oMCwgX3J1bnRpbWVDb25maWcpLnNldENvbmZpZyh7XG4gICAgc2VydmVyUnVudGltZUNvbmZpZzoge1xuICAgIH0sXG4gICAgcHVibGljUnVudGltZUNvbmZpZzogcnVudGltZUNvbmZpZyB8fCB7XG4gICAgfVxufSk7XG5sZXQgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4vLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG5pZiAoKDAsIF9yb3V0ZXIpLmhhc0Jhc2VQYXRoKGFzUGF0aCkpIHtcbiAgICBhc1BhdGggPSAoMCwgX3JvdXRlcikuZGVsQmFzZVBhdGgoYXNQYXRoKTtcbn1cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpO1xuICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJyk7XG4gICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJyk7XG4gICAgY29uc3QgeyBmb3JtYXRVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJyk7XG4gICAgaWYgKGxvY2FsZXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBsb2NhbGVzKTtcbiAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoZGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgIH0gPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuICAgIGluaXRTY3JpcHRMb2FkZXIoZGF0YS5zY3JpcHRMb2FkZXIpO1xufVxuY29uc3QgcGFnZUxvYWRlciA9IG5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGJ1aWxkSWQsIHByZWZpeCk7XG5jb25zdCByZWdpc3RlciA9IChbciwgZl0pPT5wYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKVxuO1xuaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKVxuICAgICAgICAsIDApXG4gICAgKTtcbn1cbndpbmRvdy5fX05FWFRfUCA9IFtdO1xud2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbmNvbnN0IGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkTWFuYWdlcikuZGVmYXVsdCgpO1xuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKTtcbmxldCBsYXN0UmVuZGVyUmVqZWN0O1xubGV0IHdlYnBhY2tITVI7XG5sZXQgcm91dGVyO1xuZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXI7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICByZXR1cm4gcm91dGVyLmlzU3NyO1xufTtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIC8vIFdlIGRvbid0IHVwZGF0ZSBmb3IgNDA0IHJlcXVlc3RzIGFzIHRoaXMgY2FuIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXNQYXRoIHVuZXhwZWN0ZWRseSBlLmcuIGFkZGluZyBiYXNlUGF0aCB3aGVuXG4gICAgICAgIC8vIGl0IHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnRcbiAgICAgICAgcGFnZSAhPT0gJy80MDQnICYmIHBhZ2UgIT09ICcvX2Vycm9yJyAmJiAoaXNGYWxsYmFjayB8fCBkYXRhLm5leHRFeHBvcnQgJiYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB8fCBoeWRyYXRlUHJvcHMgJiYgaHlkcmF0ZVByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgICAgICAgIHJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSArICc/JyArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nKS5hc3NpZ24oKDAsIF9xdWVyeXN0cmluZykudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpc0ZhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCAgfSA9IGxvY2F0aW9uO1xuICAgICAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAgICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW1pdHRlciA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5lbWl0dGVyID0gZW1pdHRlcjtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5mdW5jdGlvbiBfaW5pdE5leHQoKSB7XG4gICAgX2luaXROZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMgPSB7XG4gICAgfSkge1xuICAgICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgd2VicGFja0hNUiA9IG9wdHMud2VicGFja0hNUjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdGlhbEVyciA9IGh5ZHJhdGVFcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0geWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9IG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzO1xuICAgICAgICAgICAgb25QZXJmRW50cnkgPSAoeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAgfSk9PntcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IGAke0RhdGUubm93KCl9LSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDkwMDAwMDAwMDAwMDAgLSAxKSkgKyAxMDAwMDAwMDAwMDAwfWA7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmZTdGFydEVudHJ5O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdlYlZpdGFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkIHx8IHVuaXF1ZUlELFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID09IG51bGwgPyBkdXJhdGlvbiA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZScgPyAnY3VzdG9tJyA6ICd3ZWItdml0YWwnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gbnVsbCB8fCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgICAgICAoMCwgX3ZpdGFscykudHJhY2tXZWJWaXRhbE1ldHJpYyh3ZWJWaXRhbHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgICAgIC8vIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIGVudHJ5cG9pbnQuXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBoeWRyYXRlRXJyID8ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBoeWRyYXRlRXJyXG4gICAgICAgICAgICB9IDogeWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChwYWdlKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGFnZUVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDYWNoZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGFnZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgICAgICAgICBpbml0aWFsRXJyID0gKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycm9yKSA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgeyBnZXROb2RlRXJyb3IgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRXJyID09PSBoeWRyYXRlRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyBmcm9tIHRoZSBtaWRkbGV3YXJlIGFyZSByZXBvcnRlZCBhcyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBtaWRkbGV3YXJlIGlzIGNvbXBpbGVkIHVzaW5nIHRoZSBjbGllbnQgY29tcGlsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnbWlkZGxld2FyZScgaW4gaHlkcmF0ZUVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgICAgICAgICB5aWVsZCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShkeW5hbWljSWRzKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9ICgwLCBfcm91dGVyMSkuY3JlYXRlUm91dGVyKHBhZ2UsIHF1ZXJ5LCBhc1BhdGgsIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgcGFnZUxvYWRlcixcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICB3cmFwQXBwLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICAgICAgaXNGYWxsYmFjazogQm9vbGVhbihpc0ZhbGxiYWNrKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKT0+cmVuZGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIH0sIGluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIGxvY2FsZXMsXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgICAgIGlzUHJldmlld1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgICAgIHJlbmRlckN0eFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluaXROZXh0KCkge1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgX3JlbmRlciA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihyZW5kZXJpbmdQcm9wcykge1xuICAgICAgICBpZiAocmVuZGVyaW5nUHJvcHMuZXJyKSB7XG4gICAgICAgICAgICB5aWVsZCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIGRvUmVuZGVyKHJlbmRlcmluZ1Byb3BzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJFcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihlcnIgKyAnJyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBpZiAocmVuZGVyRXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICB9LCByZW5kZXJpbmdQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycjogcmVuZGVyRXJyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHMpIHtcbiAgICBjb25zdCB7IEFwcCAsIGVyciAgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICAgICAgd2VicGFja0hNUi5vblVucmVjb3ZlcmFibGVFcnJvcigpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSA8QXBwPiBzbyB0aGF0IHRoZSBgPFJlYWN0RGV2T3ZlcmxheT5gIGNhblxuICAgICAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgICAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgICAgICAgQXBwOiAoKT0+bnVsbFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvdGhlcndpc2UgdXNlcnMgY2FuJ3QgdHJhY2sgZG93biBpc3N1ZXMuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnNvbGUuZXJyb3IoYEEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkYCk7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoJy9fZXJyb3InKS50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIHJldHVybiAobGFzdEFwcFByb3BzID09PSBudWxsIHx8IGxhc3RBcHBQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKSA6IHtcbiAgICAgICAgICAgIEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGVTaGVldHNcbiAgICAgICAgfTtcbiAgICB9KS50aGVuKCh7IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKTtcbiAgICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IHBhZ2UsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIEFwcFRyZWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJFcnJvclByb3BzLnByb3BzID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT5kb1JlbmRlcihfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIH0sIHJlbmRlckVycm9yUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XG4gICAgICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgICAgICAvLyBVbmxpa2Ugd2l0aCBjcmVhdGVSb290LCB5b3UgZG9uJ3QgbmVlZCBhIHNlcGFyYXRlIHJvb3QucmVuZGVyKCkgY2FsbCBoZXJlXG4gICAgICAgICAgICByZWFjdFJvb3QgPSBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlUm9vdChkb21FbCwgcmVhY3RFbCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNoZWNrIGZvciBgLmh5ZHJhdGVgIGlzIHRoZXJlIHRvIHN1cHBvcnQgUmVhY3QgYWx0ZXJuYXRpdmVzIGxpa2UgcHJlYWN0XG4gICAgICAgIGlmIChzaG91bGRIeWRyYXRlKSB7XG4gICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlKHJlYWN0RWwsIGRvbUVsKTtcbiAgICAgICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihyZWFjdEVsLCBkb21FbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJIeWRyYXRlJykgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsICduYXZpZ2F0aW9uU3RhcnQnLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpIC8vIG1hcmsgZW5kIG9mIHJlbmRlclxuICAgIDtcbiAgICBjb25zdCBuYXZTdGFydEVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsICdtYXJrJyk7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJSZW5kZXInKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbiAgICBbXG4gICAgICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgICAgICAnTmV4dC5qcy1yZW5kZXInXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKVxuICAgICk7XG59XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgJ2JlZm9yZVJlbmRlcicsXG4gICAgICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICAncm91dGVDaGFuZ2UnXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKVxuICAgICk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIoeyBjaGlsZHJlbiAgfSkge1xuICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT5yZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpXG4gICAgICAgICAgICApXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfcm91dGVyMSkubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGhlYWRNYW5hZ2VyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9zdHlsZWRKc3guU3R5bGVSZWdpc3RyeSwgbnVsbCwgY2hpbGRyZW4pKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgfSwgd3JhcHBlZEFwcFByb3BzLCB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaHlkcmF0ZUVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB9LCBhcHBQcm9wcykpKSk7XG4gICAgfVxuO1xubGV0IGxhc3RBcHBQcm9wcztcbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0KSB7XG4gICAgbGV0IHsgQXBwICwgQ29tcG9uZW50ICwgcHJvcHMgLCBlcnIgIH0gPSBpbnB1dDtcbiAgICBsZXQgc3R5bGVTaGVldHMgPSAnaW5pdGlhbCcgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0cztcbiAgICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudDtcbiAgICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wcztcbiAgICBjb25zdCBhcHBQcm9wcyA9IF9vYmplY3RTcHJlYWQoe1xuICAgIH0sIHByb3BzLCB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9KTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gICAgLy8gUHJvbWlzZS4gSXQgc2hvdWxkIHJlbWFpbiBzeW5jaHJvbm91cy5cbiAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBpZiAoIXN0eWxlU2hlZXRzIHx8IC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJykpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCBub3NjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT09IG51bGwgfHwgbm9zY3JpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpO1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgLCB0ZXh0ICB9KT0+e1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50SHJlZnMuaGFzKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpIHtcbiAgICAgICAgaWYgKC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAvLyBXZSBjYW4gc2tpcCB0aGlzIGR1cmluZyBoeWRyYXRpb24uIFJ1bm5pbmcgaXQgd29udCBjYXVzZSBhbnkgaGFybSwgYnV0XG4gICAgICAgIC8vIHdlIG1heSBhcyB3ZWxsIHNhdmUgdGhlIENQVSBjeWNsZXM6XG4gICAgICAgIHN0eWxlU2hlZXRzICYmIC8vIEVuc3VyZSB0aGlzIHJlbmRlciB3YXMgbm90IGNhbmNlbGVkXG4gICAgICAgICFjYW5jZWxlZCkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZEhyZWZzID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpPT5zLmhyZWZcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKT0+dGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgICAgICAgZm9yKGxldCBpZHggPSAwOyBpZHggPCBjdXJyZW50SHJlZnMubGVuZ3RoOyArK2lkeCl7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJykpLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKGlucHV0LnNjcm9sbC54LCBpbnB1dC5zY3JvbGwueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Sb290Q29tbWl0KCkge1xuICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgZWxlbSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhlYWQsIHtcbiAgICAgICAgY2FsbGJhY2s6IG9uSGVhZENvbW1pdFxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBPYmplY3QuYXNzaWduKHtcbiAgICB9LCBhcHBQcm9wcykpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZUFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSlcbiAgICApO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuZnVuY3Rpb24gUm9vdCh7IGNhbGxiYWNrcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2tzIGFyZSBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spPT5jYWxsYmFjaygpXG4gICAgICAgIClcbiAgICAsIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICAvLyBXZSBzaG91bGQgYXNrIHRvIG1lYXN1cmUgdGhlIFdlYiBWaXRhbHMgYWZ0ZXIgcmVuZGVyaW5nIGNvbXBsZXRlcyBzbyB3ZVxuICAgIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfcGVyZm9ybWFuY2VSZWxheWVyKS5kZWZhdWx0KG9uUGVyZkVudHJ5KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHsgY2FsbGJhY2sgIH0pIHtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKVxuICAgICwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0TmV4dCIsInJlbmRlciIsInJlbmRlckVycm9yIiwiZW1pdHRlciIsInJvdXRlciIsInZlcnNpb24iLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9zdHlsZWRKc3giLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX21pdHQiLCJfcm91dGVyQ29udGV4dCIsIl9yb3V0ZXIiLCJfaXNEeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVDb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiX3JvdXRlQW5ub3VuY2VyIiwiX3JvdXRlcjEiLCJfaXNFcnJvciIsIl92aXRhbHMiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJuZXdPYmoiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsImkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImZvckVhY2giLCJsZW5ndGgiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJoeWRyYXRlUHJvcHMiLCJwcm9wcyIsImh5ZHJhdGVFcnIiLCJwYWdlIiwicXVlcnkiLCJidWlsZElkIiwiYXNzZXRQcmVmaXgiLCJydW50aW1lQ29uZmlnIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsImRlZmF1bHRMb2NhbGUiLCJwcmVmaXgiLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsInNldENvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiYXNQYXRoIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdERvbWFpbkxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJmb3JtYXRVcmwiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJwYXRobmFtZSIsImRldGVjdGVkTG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwibG9jYXRpb24iLCJob3N0bmFtZSIsInNjcmlwdExvYWRlciIsImluaXRTY3JpcHRMb2FkZXIiLCJwYWdlTG9hZGVyIiwicmVnaXN0ZXIiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwic2V0VGltZW91dCIsInB1c2giLCJoZWFkTWFuYWdlciIsImFwcEVsZW1lbnQiLCJsYXN0UmVuZGVyUmVqZWN0Iiwid2VicGFja0hNUiIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiZ2V0SXNTc3IiLCJpc1NzciIsIkNvbnRhaW5lciIsImNvbXBvbmVudERpZENhdGNoIiwiY29tcG9uZW50RXJyIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJDYWNoZWRDb21wb25lbnQiLCJfaW5pdE5leHQiLCJvcHRzIiwiaW5pdGlhbEVyciIsImFwcEVudHJ5cG9pbnQiLCJhcHAiLCJtb2QiLCJleHBvcnRlZFJlcG9ydFdlYlZpdGFscyIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0Tm9kZUVycm9yIiwicmVuZGVyQ3R4Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJyZXBvcnRXZWJWaXRhbHMiLCJuYW1lIiwiaWQiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIk1hdGgiLCJEYXRlIiwibm93IiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwidHJhY2tXZWJWaXRhbE1ldHJpYyIsIkVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsIm5vZGUiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJzY3JvbGwiLCJpbml0aWFsIiwiX3JlbmRlciIsInJlbmRlcmluZ1Byb3BzIiwicmVuZGVyRXJyIiwiZG9SZW5kZXIiLCJjYW5jZWxsZWQiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJzdHlsZVNoZWV0cyIsImNvbnNvbGUiLCJsb2FkUGFnZSIsIkVycm9yQ29tcG9uZW50IiwibGFzdEFwcFByb3BzIiwibSIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJyZWFjdEVsIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIl9fTkVYVF9SRUFDVF9ST09UIiwiaHlkcmF0ZVJvb3QiLCJoeWRyYXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsImNhdGNoIiwiUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiU3R5bGVSZWdpc3RyeSIsIndyYXBwZWRBcHBQcm9wcyIsImFwcFByb3BzIiwib25TdGFydCIsImN1cnJlbnRTdHlsZVRhZ3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3VycmVudEhyZWZzIiwiU2V0IiwidGFnIiwiZ2V0QXR0cmlidXRlIiwibm9zY3JpcHQiLCJxdWVyeVNlbGVjdG9yIiwibm9uY2UiLCJocmVmIiwidGV4dCIsImhhcyIsInN0eWxlVGFnIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJvbkhlYWRDb21taXQiLCJjYW5jZWxlZCIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGxUbyIsIngiLCJ5Iiwib25Sb290Q29tbWl0IiwicmVzb2x2ZVByb21pc2UiLCJyZW5kZXJQcm9taXNlIiwiZWxlbSIsIkZyYWdtZW50IiwiSGVhZCIsImNhbGxiYWNrIiwiUG9ydGFsIiwidHlwZSIsIlJvdXRlQW5ub3VuY2VyIiwiUm9vdCIsImNhbGxiYWNrcyIsIl9fTkVYVF9TVFJJQ1RfTU9ERSIsIlN0cmljdE1vZGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nvar _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nvar _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nvar _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// Temporary workaround for the issue described here:\n// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123\n// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import\n// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries\n// eslint-disable-next-line no-unused-expressions\nPromise.resolve().then(function() {\n    return _interopRequireWildcard(__webpack_require__(/*! ./dev/noop */ \"./node_modules/next/dist/client/dev/noop.js\"));\n});\n;\nvar assetPrefix = window.__NEXT_DATA__.assetPrefix;\nvar prefix = assetPrefix || '';\nvar webpackHMR = (0, _webpackHotMiddlewareClient).default();\n(0, _websocket).connectHMR({\n    path: \"\".concat(prefix, \"/_next/webpack-hmr\")\n});\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter,\n    render: _.render,\n    renderError: _.renderError\n};\n(0, _).initNext({\n    webpackHMR: webpackHMR\n}).then(function(param) {\n    var renderCtx = param.renderCtx;\n    var devPagesManifestListener = function devPagesManifestListener(event) {\n        if (event.data.indexOf('devPagesManifest') !== -1) {\n            fetch(\"\".concat(prefix, \"/_next/static/development/_devPagesManifest.json\")).then(function(res) {\n                return res.json();\n            }).then(function(manifest) {\n                window.__DEV_PAGES_MANIFEST = manifest;\n            }).catch(function(err) {\n                console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n        } else if (event.data.indexOf('middlewareChanges') !== -1) {\n            return window.location.reload();\n        } else if (event.data.indexOf('serverOnlyChanges') !== -1) {\n            var pages = JSON.parse(event.data).pages;\n            // Make sure to reload when the dev-overlay is showing for an\n            // API route\n            if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                return window.location.reload();\n            }\n            if (!_.router.clc && pages.includes(_.router.pathname)) {\n                console.log('Refreshing page data due to server-side change');\n                buildIndicatorHandler('building');\n                var clearIndicator = function() {\n                    return buildIndicatorHandler('built');\n                };\n                _.router.replace(_.router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(_.router.query), new URLSearchParams(location.search))), _.router.asPath).finally(clearIndicator);\n            }\n        }\n    };\n    (0, _onDemandEntriesClient).default();\n    var buildIndicatorHandler = function() {\n    };\n    (0, _websocket).addMessageListener(devPagesManifestListener);\n    if (true) {\n        (0, _devBuildWatcher).default(function(handler) {\n            buildIndicatorHandler = handler;\n        });\n    }\n    // delay rendering until after styles have been applied in development\n    (0, _fouc).displayContent(function() {\n        (0, _).render(renderCtx);\n    });\n}).catch(function(err) {\n    console.error('Error was not caught', err);\n}); //# sourceMappingURL=next-dev.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaLEdBQUcsQ0FBQ0EsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLG9EQUFJO0FBQ3BCLEdBQUcsQ0FBQ0Msc0JBQXNCLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVHQUFnQztBQUM1RixHQUFHLENBQUNHLDJCQUEyQixHQUFHRCxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyxpSEFBcUM7QUFDdEcsR0FBRyxDQUFDSSxnQkFBZ0IsR0FBR0Ysc0JBQXNCLENBQUNGLG1CQUFPLENBQUMseUZBQXlCO0FBQy9FLEdBQUcsQ0FBQ0ssS0FBSyxHQUFHTCxtQkFBTyxDQUFDLCtEQUFZO0FBQ2hDLEdBQUcsQ0FBQ00sVUFBVSxHQUFHTixtQkFBTyxDQUFDLHFHQUErQjtBQUN4RCxHQUFHLENBQUNPLFlBQVksR0FBR1AsbUJBQU8sQ0FBQyxvSEFBd0M7U0FDMURFLHNCQUFzQixDQUFDTSxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDRSxPQUFPLEVBQUVGLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUFxRDtBQUNyRCxFQUF1RTtBQUN2RSxFQUFxRztBQUNyRyxFQUE2RztBQUM3RyxFQUFpRDs7dURBQzFDLCtEQUFZOzs7QUFDbkIsR0FBSyxDQUFvQkcsV0FBVyxHQUFXQyxNQUFNLENBQTdDQyxhQUFhLENBQUlGLFdBQVc7QUFDcEMsR0FBSyxDQUFDRyxNQUFNLEdBQUdILFdBQVcsSUFBSSxDQUFFO0FBQ2hDLEdBQUssQ0FBQ0ksVUFBVSxJQUFJLENBQUMsRUFBRVosMkJBQTJCLEVBQUVPLE9BQU87Q0FDMUQsQ0FBQyxFQUFFSixVQUFVLEVBQUVVLFVBQVUsQ0FBQyxDQUFDO0lBQ3hCQyxJ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SyxHQUFHLEdBQUcsQ0FBQ1UsZUFBZSxDQUFDaEIsUUFBUSxDQUFDaUIsTUFBTSxLQUFLMUQsQ0FBQyxDQUFDcUIsTUFBTSxDQUFDc0MsTUFBTSxFQUFFQyxPQUFPLENBQUNSLGNBQWM7WUFDeE4sQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0tBNUJBLENBQUMsRUFBRWxELHNCQUFzQixFQUFFUyxPQUFPO0lBQ25DLEdBQUcsQ0FBQ3dDLHFCQUFxQixHQUFHLFFBQzlCLEdBRGtDLENBQUM7SUFDakMsQ0FBQztLQTJCQSxDQUFDLEVBQUU1QyxVQUFVLEVBQUVzRCxrQkFBa0IsQ0FBQ2pDLHdCQUF3QjtJQUMzRCxFQUFFLEVBQUVrQyxJQUFrQyxFQUFFLENBQUM7U0FDcEMsQ0FBQyxFQUFFekQsZ0JBQWdCLEVBQUVNLE9BQU8sQ0FBQyxRQUFRLENBQVBzRCxPQUFPLEVBQUcsQ0FBQztZQUN0Q2QscUJBQXFCLEdBQUdjLE9BQU87UUFDbkMsQ0FBQztJQUNMLENBQUM7SUFDRCxFQUFzRTtLQUNyRSxDQUFDLEVBQUUzRCxLQUFLLEVBQUU0RCxjQUFjLENBQUMsUUFDNUIsR0FEZ0MsQ0FBQztTQUMxQixDQUFDLEVBQUVsRSxDQUFDLEVBQUV1QixNQUFNLENBQUNJLFNBQVM7SUFDM0IsQ0FBQztBQUNMLENBQUMsRUFBRVUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7SUFDYkMsT0FBTyxDQUFDNEIsS0FBSyxDQUFDLENBQXNCLHVCQUFFN0IsR0FBRztBQUM3QyxDQUFDLEVBRUQsQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbmV4dC1kZXYuanM/MzUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfID0gcmVxdWlyZShcIi4vXCIpO1xudmFyIF9vbkRlbWFuZEVudHJpZXNDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xudmFyIF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50XCIpKTtcbnZhciBfZGV2QnVpbGRXYXRjaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvZGV2LWJ1aWxkLXdhdGNoZXJcIikpO1xudmFyIF9mb3VjID0gcmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG4vLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgdGhlIGlzc3VlIGRlc2NyaWJlZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzc1I2lzc3VlY29tbWVudC00MDc0MzgxMjNcbi8vIFRoZSBydW50aW1lQ2h1bmsgZG9lc24ndCBoYXZlIGR5bmFtaWMgaW1wb3J0IGhhbmRsaW5nIGNvZGUgd2hlbiB0aGVyZSBoYXNuJ3QgYmVlbiBhIGR5bmFtaWMgaW1wb3J0XG4vLyBUaGUgcnVudGltZUNodW5rIGNhbid0IGhvdCByZWxvYWQgaXRzZWxmIGN1cnJlbnRseSB0byBjb3JyZWN0IGl0IHdoZW4gYWRkaW5nIHBhZ2VzIHVzaW5nIG9uLWRlbWFuZC1lbnRyaWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5pbXBvcnQoJy4vZGV2L25vb3AnKTs7XG5jb25zdCB7IF9fTkVYVF9EQVRBX186IHsgYXNzZXRQcmVmaXggIH0gLCAgfSA9IHdpbmRvdztcbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnO1xuY29uc3Qgd2VicGFja0hNUiA9ICgwLCBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQpLmRlZmF1bHQoKTtcbigwLCBfd2Vic29ja2V0KS5jb25uZWN0SE1SKHtcbiAgICBwYXRoOiBgJHtwcmVmaXh9L19uZXh0L3dlYnBhY2staG1yYFxufSk7XG53aW5kb3cubmV4dCA9IHtcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgLy8gcm91dGVyIGlzIGluaXRpYWxpemVkIGxhdGVyIHNvIGl0IGhhcyB0byBiZSBsaXZlLWJpbmRlZFxuICAgIGdldCByb3V0ZXIgKCkge1xuICAgICAgICByZXR1cm4gXy5yb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBfLmVtaXR0ZXIsXG4gICAgcmVuZGVyOiBfLnJlbmRlcixcbiAgICByZW5kZXJFcnJvcjogXy5yZW5kZXJFcnJvclxufTtcbigwLCBfKS5pbml0TmV4dCh7XG4gICAgd2VicGFja0hNUlxufSkudGhlbigoeyByZW5kZXJDdHggIH0pPT57XG4gICAgKDAsIF9vbkRlbWFuZEVudHJpZXNDbGllbnQpLmRlZmF1bHQoKTtcbiAgICBsZXQgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gKCk9PntcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdkZXZQYWdlc01hbmlmZXN0JykgIT09IC0xKSB7XG4gICAgICAgICAgICBmZXRjaChgJHtwcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKVxuICAgICAgICAgICAgKS50aGVuKChtYW5pZmVzdCk9PntcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBkZXZQYWdlc01hbmlmZXN0YCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignbWlkZGxld2FyZUNoYW5nZXMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdzZXJ2ZXJPbmx5Q2hhbmdlcycpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlcyAgfSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVsb2FkIHdoZW4gdGhlIGRldi1vdmVybGF5IGlzIHNob3dpbmcgZm9yIGFuXG4gICAgICAgICAgICAvLyBBUEkgcm91dGVcbiAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhfLnJvdXRlci5xdWVyeS5fX05FWFRfUEFHRSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLnJvdXRlci5jbGMgJiYgcGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgcGFnZSBkYXRhIGR1ZSB0byBzZXJ2ZXItc2lkZSBjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIoJ2J1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYXJJbmRpY2F0b3IgPSAoKT0+YnVpbGRJbmRpY2F0b3JIYW5kbGVyKCdidWlsdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIF8ucm91dGVyLnJlcGxhY2UoXy5yb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXy5yb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgXy5yb3V0ZXIuYXNQYXRoKS5maW5hbGx5KGNsZWFySW5kaWNhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcik7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpIHtcbiAgICAgICAgKDAsIF9kZXZCdWlsZFdhdGNoZXIpLmRlZmF1bHQoKGhhbmRsZXIpPT57XG4gICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZGVsYXkgcmVuZGVyaW5nIHVudGlsIGFmdGVyIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZCBpbiBkZXZlbG9wbWVudFxuICAgICgwLCBfZm91YykuZGlzcGxheUNvbnRlbnQoKCk9PntcbiAgICAgICAgKDAsIF8pLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH0pO1xufSkuY2F0Y2goKGVycik9PntcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsIGVycik7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX29uRGVtYW5kRW50cmllc0NsaWVudCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQiLCJfZGV2QnVpbGRXYXRjaGVyIiwiX2ZvdWMiLCJfd2Vic29ja2V0IiwiX3F1ZXJ5c3RyaW5nIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJhc3NldFByZWZpeCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJ3ZWJwYWNrSE1SIiwiY29ubmVjdEhNUiIsInBhdGgiLCJuZXh0IiwidmVyc2lvbiIsInJvdXRlciIsImVtaXR0ZXIiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsImluaXROZXh0IiwidGhlbiIsInJlbmRlckN0eCIsImRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsImluZGV4T2YiLCJmZXRjaCIsInJlcyIsImpzb24iLCJtYW5pZmVzdCIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwibG9nIiwibG9jYXRpb24iLCJyZWxvYWQiLCJwYWdlcyIsIkpTT04iLCJwYXJzZSIsImluY2x1ZGVzIiwicXVlcnkiLCJfX05FWFRfUEFHRSIsImNsYyIsInBhdGhuYW1lIiwiYnVpbGRJbmRpY2F0b3JIYW5kbGVyIiwiY2xlYXJJbmRpY2F0b3IiLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImFzUGF0aCIsImZpbmFsbHkiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0JVSUxEX0lORElDQVRPUiIsImhhbmRsZXIiLCJkaXNwbGF5Q29udGVudCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js?678a\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js?3e74\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nvar _resolveRewrites = _interopRequireDefault1(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar detectDomainLocale;\nif (false) {}\nvar basePath =  false || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    var pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var detectedDomain; } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    var queryIndex = path.indexOf('?');\n    var hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = \"/\".concat(path);\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils).getLocationOrigin();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = '';\n    var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || '';\n        var _param = dynamicGroups[param], repeat = _param.repeat, optional = _param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    var filteredQuery = {\n    };\n    Object.keys(query).forEach(function(key) {\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        var interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            var ref = interpolateAs(finalUrl.pathname, finalUrl.pathname, query), result = ref.result, params = ref.params;\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var ref = _slicedToArray(resolveHref(router, url, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefHadOrigin = resolvedHref.startsWith(origin);\n    var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then(function(res) {\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1);\n            }\n            if (res.status === 404) {\n                return res.json().then(function(data) {\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(\"Failed to load static props\");\n                });\n            }\n            throw new Error(\"Failed to load static props\");\n        }\n        return res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, inflightCache, persistCache) {\n    var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1).catch(function(err) {\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then(function(data) {\n        if (!persistCache || 'development' !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch(function(err) {\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname2, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = function(e) {\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, idx = state.idx;\n            if (false) { var v; }\n            _this._idx = idx;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === _this.asPath && pathname1 === _this.pathname) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname2);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname2 !== '/_error') {\n            this.components[this.route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        this.pathname = pathname2;\n        this.query = query1;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname2) && self.__NEXT_DATA__.autoExport;\n        this.asPath = autoExportDynamic ? pathname2 : as1;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isFallback = isFallback;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = false;\n        if (false) {}\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as1.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options1 = {\n                    locale: locale\n                };\n                options1._shouldResolveHref = as1 !== pathname2;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname2),\n                    query: query1\n                }), (0, _utils).getURL(), options1);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('pushState', url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('replaceState', url, as, options);\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var shouldResolveHref, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, shallow, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, resolvedAs, rewritesResult, effect, route, parsedAs1, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref, ref1, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll, shouldScroll, resetScroll;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (isLocalURL(url)) {\n                                    _ctx.next = 3;\n                                    break;\n                                }\n                                window.location.href = url;\n                                return _ctx.abrupt(\"return\", false);\n                            case 3:\n                                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                if (options._h) {\n                                    this.isReady = true;\n                                }\n                                prevLocale = this.locale;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n                                if (typeof options.locale === 'undefined') {\n                                    options.locale = this.locale;\n                                }\n                                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                                if (localePathResult.detectedLocale) {\n                                    this.locale = localePathResult.detectedLocale;\n                                    parsedAs.pathname = addBasePath(parsedAs.pathname);\n                                    as = (0, _utils).formatWithValidation(parsedAs);\n                                    url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n                                }\n                                didNavigate = false;\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale);\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                if (!didNavigate) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 18:\n                                if (!options._h) {\n                                    this.isSsr = false;\n                                }\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark('routeChange');\n                                }\n                                var ref8, ref2;\n                                ref8 = options, ref2 = ref8.shallow, shallow = ref2 === void 0 ? false : ref2, ref8;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (this._inFlightRoute) {\n                                    this.abortComponentLoad(this._inFlightRoute, routeProps);\n                                }\n                                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n                                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n                                this._inFlightRoute = as;\n                                localeChange = prevLocale !== this.locale;\n                                if (!(!options._h && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                                    _ctx.next = 35;\n                                    break;\n                                }\n                                this.asPath = cleanedAs;\n                                Router.events.emit('hashChangeStart', as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                this.changeState(method, url, as, options);\n                                this.scrollToHash(cleanedAs);\n                                this.notify(this.components[this.route], null);\n                                Router.events.emit('hashChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 35:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                var ref3;\n                                ref3 = parsed, pathname = ref3.pathname, query = ref3.query, ref3;\n                                ;\n                                _ctx.prev = 38;\n                                _ctx.next = 41;\n                                return Promise.all([\n                                    this.pageLoader.getPageList(),\n                                    (0, _routeLoader).getClientBuildManifest(),\n                                    this.pageLoader.getMiddlewareList(), \n                                ]);\n                            case 41:\n                                var ref4, ref5;\n                                ref4 = _ctx.sent, pages = ref4[0], ref5 = ref4[1], rewrites = ref5.__rewrites, ref5, ref4;\n                                _ctx.next = 48;\n                                break;\n                            case 44:\n                                _ctx.prev = 44;\n                                _ctx.t0 = _ctx[\"catch\"](38);\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 48:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = 'replaceState';\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n                                if (shouldResolveHref && pathname !== '/_error') {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = addBasePath(pathname);\n                                            url = (0, _utils).formatWithValidation(parsed);\n                                        }\n                                    }\n                                }\n                                if (isLocalURL(as)) {\n                                    _ctx.next = 57;\n                                    break;\n                                }\n                                if (false) {}\n                                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                            case 55:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 57:\n                                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n                                _ctx.next = 60;\n                                return this._preflightRequest({\n                                    as: as,\n                                    cache: 'development' === 'production',\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 60:\n                                effect = _ctx.sent;\n                                if (!(effect.type === 'rewrite')) {\n                                    _ctx.next = 65;\n                                    break;\n                                }\n                                {\n                                    query = _objectSpread({\n                                    }, query, effect.parsedAs.query);\n                                    resolvedAs = effect.asPath;\n                                    pathname = effect.resolvedHref;\n                                    parsed.pathname = effect.resolvedHref;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 77;\n                                break;\n                            case 65:\n                                if (!(effect.type === 'redirect' && effect.newAs)) {\n                                    _ctx.next = 69;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", this.change(method, effect.newUrl, effect.newAs, options));\n                            case 69:\n                                if (!(effect.type === 'redirect' && effect.destination)) {\n                                    _ctx.next = 74;\n                                    break;\n                                }\n                                window.location.href = effect.destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 74:\n                                if (!(effect.type === 'refresh')) {\n                                    _ctx.next = 77;\n                                    break;\n                                }\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 77:\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                                    _ctx.next = 93;\n                                    break;\n                                }\n                                parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                asPathname = parsedAs1.pathname;\n                                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                shouldInterpolate = route === asPathname;\n                                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n                                };\n                                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                                    _ctx.next = 92;\n                                    break;\n                                }\n                                missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                    return !query[param];\n                                });\n                                if (!(missingParams.length > 0)) {\n                                    _ctx.next = 90;\n                                    break;\n                                }\n                                if (true) {\n                                    console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                                }\n                                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n                            case 90:\n                                _ctx.next = 93;\n                                break;\n                            case 92:\n                                if (shouldInterpolate) {\n                                    as = (0, _utils).formatWithValidation(Object.assign({\n                                    }, parsedAs1, {\n                                        pathname: interpolatedAs.result,\n                                        query: omitParmsFromQuery(query, interpolatedAs.params)\n                                    }));\n                                } else {\n                                    // Merge params into `query`, overwriting any specified in search\n                                    Object.assign(query, routeMatch);\n                                }\n                            case 93:\n                                Router.events.emit('routeChangeStart', as, routeProps);\n                                _ctx.prev = 94;\n                                ;\n                                _ctx.next = 98;\n                                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n                            case 98:\n                                routeInfo = _ctx.sent;\n                                var ref6;\n                                ref6 = routeInfo, error = ref6.error, props = ref6.props, __N_SSG = ref6.__N_SSG, __N_SSP = ref6.__N_SSP, ref6;\n                                if (!((__N_SSG || __N_SSP) && props)) {\n                                    _ctx.next = 125;\n                                    break;\n                                }\n                                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                                    _ctx.next = 110;\n                                    break;\n                                }\n                                destination = props.pageProps.__N_REDIRECT;\n                                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                                    _ctx.next = 108;\n                                    break;\n                                }\n                                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                var ref7;\n                                ref7 = prepareUrlAs(this, destination, destination), newUrl = ref7.url, newAs = ref7.as, ref7;\n                                return _ctx.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n                            case 108:\n                                window.location.href = destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 110:\n                                this.isPreview = !!props.__N_PREVIEW;\n                                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                                    _ctx.next = 125;\n                                    break;\n                                }\n                                ;\n                                _ctx.prev = 113;\n                                _ctx.next = 116;\n                                return this.fetchComponent('/404');\n                            case 116:\n                                notFoundRoute = '/404';\n                                _ctx.next = 122;\n                                break;\n                            case 119:\n                                _ctx.prev = 119;\n                                _ctx.t1 = _ctx[\"catch\"](113);\n                                notFoundRoute = '/_error';\n                            case 122:\n                                _ctx.next = 124;\n                                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                                    shallow: false\n                                });\n                            case 124:\n                                routeInfo = _ctx.sent;\n                            case 125:\n                                Router.events.emit('beforeHistoryChange', as, routeProps);\n                                this.changeState(method, url, as, options);\n                                if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && this.route === route;\n                                ;\n                                shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                _ctx.next = 134;\n                                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(function(e) {\n                                    if (e.cancelled) error = error || e;\n                                    else throw e;\n                                });\n                            case 134:\n                                if (!error) {\n                                    _ctx.next = 137;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                                throw error;\n                            case 137:\n                                if (false) {}\n                                Router.events.emit('routeChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 142:\n                                _ctx.prev = 142;\n                                _ctx.t2 = _ctx[\"catch\"](94);\n                                if (!((0, _isError).default(_ctx.t2) && _ctx.t2.cancelled)) {\n                                    _ctx.next = 146;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", false);\n                            case 146:\n                                throw _ctx.t2;\n                            case 147:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            38,\n                            44\n                        ],\n                        [\n                            94,\n                            142\n                        ],\n                        [\n                            113,\n                            119\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (true) {\n                    if (typeof window.history === 'undefined') {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === 'undefined') {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    '', as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var Component, styleSheets, props, routeInfo;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (!err.cancelled) {\n                                    _ctx.next = 2;\n                                    break;\n                                }\n                                // bubble up cancellation errors\n                                throw err;\n                            case 2:\n                                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                                    _ctx.next = 6;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', err, as, routeProps);\n                                // If we can't load the page it could be one of following reasons\n                                //  1. Page doesn't exists\n                                //  2. Page does exist in a different zone\n                                //  3. Internal error while loading the page\n                                // So, doing a hard reload is the proper way to deal with this.\n                                window.location.href = as;\n                                // Changing the URL doesn't block executing the current code path.\n                                // So let's throw a cancellation error stop the routing logic.\n                                throw buildCancellationError();\n                            case 6:\n                                _ctx.prev = 6;\n                                ;\n                                ;\n                                ;\n                                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                                    _ctx.next = 14;\n                                    break;\n                                }\n                                _ctx.next = 13;\n                                return this.fetchComponent('/_error');\n                            case 13:\n                                var ref;\n                                ref = _ctx.sent, Component = ref.page, styleSheets = ref.styleSheets, ref;\n                            case 14:\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (routeInfo.props) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                _ctx.prev = 16;\n                                _ctx.next = 19;\n                                return this.getInitialProps(Component, {\n                                    err: err,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 19:\n                                routeInfo.props = _ctx.sent;\n                                _ctx.next = 26;\n                                break;\n                            case 22:\n                                _ctx.prev = 22;\n                                _ctx.t0 = _ctx[\"catch\"](16);\n                                console.error('Error in error page `getInitialProps`: ', _ctx.t0);\n                                routeInfo.props = {\n                                };\n                            case 26:\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 29:\n                                _ctx.prev = 29;\n                                _ctx.t1 = _ctx[\"catch\"](6);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps, true));\n                            case 32:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            6,\n                            29\n                        ],\n                        [\n                            16,\n                            22\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, isValidElementType, dataHref, props;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.prev = 0;\n                                _this = this;\n                                existingRouteInfo = this.components[route];\n                                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {\n                                    _ctx.next = 5;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", existingRouteInfo);\n                            case 5:\n                                cachedRouteInfo = undefined;\n                                // can only use non-initial route info\n                                // cannot reuse route info in development since it can change after HMR\n                                if (false) {}\n                                _ctx.t0 = cachedRouteInfo;\n                                if (_ctx.t0) {\n                                    _ctx.next = 12;\n                                    break;\n                                }\n                                _ctx.next = 11;\n                                return this.fetchComponent(route).then(function(res) {\n                                    return {\n                                        Component: res.page,\n                                        styleSheets: res.styleSheets,\n                                        __N_SSG: res.mod.__N_SSG,\n                                        __N_SSP: res.mod.__N_SSP\n                                    };\n                                });\n                            case 11:\n                                _ctx.t0 = _ctx.sent;\n                            case 12:\n                                routeInfo = _ctx.t0;\n                                var ref;\n                                ref = routeInfo, Component = ref.Component, __N_SSG = ref.__N_SSG, __N_SSP = ref.__N_SSP, ref;\n                                if (false) {}\n                                isValidElementType = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType;\n                                if (isValidElementType(Component)) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n                            case 18:\n                                ;\n                                if (__N_SSG || __N_SSP) {\n                                    dataHref = this.pageLoader.getDataHref((0, _utils).formatWithValidation({\n                                        pathname: pathname,\n                                        query: query\n                                    }), resolvedAs, __N_SSG, this.locale);\n                                }\n                                _ctx.next = 22;\n                                return this._getData(function() {\n                                    return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this.isSsr, __N_SSG ? _this.sdc : _this.sdr, !!__N_SSG) : _this.getInitialProps(Component, {\n                                        pathname: pathname,\n                                        query: query,\n                                        asPath: as,\n                                        locale: _this.locale,\n                                        locales: _this.locales,\n                                        defaultLocale: _this.defaultLocale\n                                    });\n                                });\n                            case 22:\n                                props = _ctx.sent;\n                                routeInfo.props = props;\n                                this.components[route] = routeInfo;\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 28:\n                                _ctx.prev = 28;\n                                _ctx.t1 = _ctx[\"catch\"](0);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps));\n                            case 31:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            28\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(route, pathname, query, as, data, resetScroll) {\n                this.isFallback = false;\n                this.route = route;\n                this.pathname = pathname;\n                this.query = query;\n                this.asPath = as;\n                return this.notify(data, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var ref = _slicedToArray(this.asPath.split('#'), 2), oldUrlNoHash = ref[0], oldHash = ref[1];\n                var ref1 = _slicedToArray(as.split('#'), 2), newUrlNoHash = ref1[0], newHash = ref1[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var ref = _slicedToArray(as.split('#'), 2), hash = ref[1];\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === '' || hash === 'top') {\n                    window.scrollTo(0, 0);\n                    return;\n                }\n                // First we check if the element by id is found\n                var idEl = document.getElementById(hash);\n                if (idEl) {\n                    idEl.scrollIntoView();\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(hash)[0];\n                if (nameEl) {\n                    nameEl.scrollIntoView();\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, param, param1) {\n                var asPath = param === void 0 ? url : param, options = param1 === void 0 ? {\n                } : param1;\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, rewrites, rewritesResult, effects, route;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _this = this;\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                var ref;\n                                ref = parsed, pathname = ref.pathname, query = ref.query, ref;\n                                if (false) {}\n                                _ctx.next = 6;\n                                return this.pageLoader.getPageList();\n                            case 6:\n                                pages = _ctx.sent;\n                                resolvedAs = asPath;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                ;\n                                _ctx.next = 12;\n                                return (0, _routeLoader).getClientBuildManifest();\n                            case 12:\n                                var ref9;\n                                ref9 = _ctx.sent, rewrites = ref9.__rewrites, ref9;\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, this.locales);\n                                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 19;\n                                break;\n                            case 18:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = pathname;\n                                        url = (0, _utils).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 19:\n                                if (false) {}\n                                return _ctx.abrupt(\"return\");\n                            case 21:\n                                _ctx.next = 23;\n                                return this._preflightRequest({\n                                    as: asPath,\n                                    cache: true,\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 23:\n                                effects = _ctx.sent;\n                                if (effects.type === 'rewrite') {\n                                    parsed.pathname = effects.resolvedHref;\n                                    pathname = effects.resolvedHref;\n                                    query = _objectSpread({\n                                    }, query, effects.parsedAs.query);\n                                    resolvedAs = effects.asPath;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                _ctx.next = 28;\n                                return Promise.all([\n                                    this.pageLoader._isSsg(route).then(function(isSsg) {\n                                        return isSsg ? fetchNextData(_this.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : _this.locale), false, _this.sdc, true) : false;\n                                    }),\n                                    this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n                                ]);\n                            case 28:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, cancelled, cancel, handleCancelled, componentResult;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _this = this;\n                                cancelled = false;\n                                cancel = this.clc = function() {\n                                    cancelled = true;\n                                };\n                                handleCancelled = function() {\n                                    if (cancelled) {\n                                        var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                                        error.cancelled = true;\n                                        throw error;\n                                    }\n                                    if (cancel === _this.clc) {\n                                        _this.clc = null;\n                                    }\n                                };\n                                _ctx.prev = 4;\n                                _ctx.next = 7;\n                                return this.pageLoader.loadPage(route);\n                            case 7:\n                                componentResult = _ctx.sent;\n                                handleCancelled();\n                                return _ctx.abrupt(\"return\", componentResult);\n                            case 12:\n                                _ctx.prev = 12;\n                                _ctx.t0 = _ctx[\"catch\"](4);\n                                handleCancelled();\n                                throw _ctx.t0;\n                            case 16:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            4,\n                            12\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error('Loading initial props cancelled');\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_preflightRequest\",\n            value: function _preflightRequest(options) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var ref, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, newUrl, newAs;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                ;\n                                cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n                                _ctx.next = 4;\n                                return this.pageLoader.getMiddlewareList();\n                            case 4:\n                                fns = _ctx.sent;\n                                requiresPreflight = fns.some(function(middleware) {\n                                    return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware))(cleanedAs);\n                                });\n                                if (requiresPreflight) {\n                                    _ctx.next = 8;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 8:\n                                _ctx.next = 10;\n                                return this._getPreflightData({\n                                    preflightHref: options.as,\n                                    shouldCache: options.cache\n                                });\n                            case 10:\n                                preflight = _ctx.sent;\n                                if (!((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/'))) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n                                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n                                ;\n                                ;\n                                if (options.pages.includes(fsPathname)) {\n                                    matchedPage = true;\n                                    resolvedHref = fsPathname;\n                                } else {\n                                    resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                                    if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                                        matchedPage = true;\n                                    }\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'rewrite',\n                                    asPath: parsed.pathname,\n                                    parsedAs: parsed,\n                                    matchedPage: matchedPage,\n                                    resolvedHref: resolvedHref\n                                });\n                            case 18:\n                                if (!preflight.redirect) {\n                                    _ctx.next = 24;\n                                    break;\n                                }\n                                if (!preflight.redirect.startsWith('/')) {\n                                    _ctx.next = 23;\n                                    break;\n                                }\n                                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                                var ref10;\n                                ref10 = prepareUrlAs(this, cleanRedirect, cleanRedirect), newUrl = ref10.url, newAs = ref10.as, ref10;\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    newUrl: newUrl,\n                                    newAs: newAs\n                                });\n                            case 23:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: preflight.redirect\n                                });\n                            case 24:\n                                if (!preflight.refresh) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'refresh'\n                                });\n                            case 26:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 27:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getPreflightData\",\n            value: function _getPreflightData(params) {\n                var _this = this, _this1 = this;\n                var preflightHref = params.preflightHref, _shouldCache = params.shouldCache, shouldCache = _shouldCache === void 0 ? false : _shouldCache;\n                var ref = new URL(preflightHref, window.location.href), cacheKey = ref.href;\n                if (false) {}\n                return fetch(preflightHref, {\n                    method: 'HEAD',\n                    credentials: 'same-origin',\n                    headers: {\n                        'x-middleware-preflight': '1'\n                    }\n                }).then(function(res) {\n                    if (!res.ok) {\n                        throw new Error(\"Failed to preflight request\");\n                    }\n                    return {\n                        redirect: res.headers.get('Location'),\n                        refresh: res.headers.has('x-middleware-refresh'),\n                        rewrite: res.headers.get('x-middleware-rewrite')\n                    };\n                }).then(function(data) {\n                    if (shouldCache) {\n                        _this.sde[cacheKey] = data;\n                    }\n                    return data;\n                }).catch(function(err) {\n                    delete _this1.sde[cacheKey];\n                    throw err;\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var ref = this.components['/_app'], App = ref.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"abortComponentLoad\",\n            value: function abortComponentLoad(as, routeProps) {\n                if (this.clc) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n                    this.clc();\n                    this.clc = null;\n                }\n            }\n        },\n        {\n            key: \"notify\",\n            value: function notify(data, resetScroll) {\n                return this.sub(data, this.components['/_app'].Component, resetScroll);\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRSxlQUFlO0FBQ3pDRixpQkFBaUIsR0FBR0csU0FBUztBQUM3QkgsaUJBQWlCLEdBQUdJLFNBQVM7QUFDN0JKLG1CQUFtQixHQUFHSyxXQUFXO0FBQ2pDTCxtQkFBbUIsR0FBR00sV0FBVztBQUNqQ04sbUJBQW1CLEdBQUdPLFdBQVc7QUFDakNQLGtCQUFrQixHQUFHUSxVQUFVO0FBQy9CUixxQkFBcUIsR0FBR1MsYUFBYTtBQUNyQ1QsbUJBQW1CLEdBQUdVLFdBQVc7QUFDakNWLGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDWSx1QkFBdUIsR0FBR0MsbUJBQU8sQ0FBQyw2R0FBMEM7QUFDaEYsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMscUZBQThCO0FBQ3pELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHQyx1QkFBc0IsQ0FBQ0gsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDckUsR0FBRyxDQUFDSSxvQkFBb0IsR0FBR0osbUJBQU8sQ0FBQyw0R0FBdUM7QUFDMUUsR0FBRyxDQUFDSyxvQkFBb0IsR0FBR0wsbUJBQU8sQ0FBQyw2R0FBK0I7QUFDbEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdILHVCQUFzQixDQUFDSCxtQkFBTyxDQUFDLDREQUFTO0FBQ3BELEdBQUcsQ0FBQ08sTUFBTSxHQUFHUCxtQkFBTyxDQUFDLDhEQUFVO0FBQy9CLEdBQUcsQ0FBQ1EsVUFBVSxHQUFHUixtQkFBTyxDQUFDLDBGQUFvQjtBQUM3QyxHQUFHLENBQUNTLGlCQUFpQixHQUFHVCxtQkFBTyxDQUFDLDBHQUE0QjtBQUM1RCxHQUFHLENBQUNVLFlBQVksR0FBR1YsbUJBQU8sQ0FBQyxpR0FBcUI7QUFDaEQsR0FBRyxDQUFDVyxnQkFBZ0IsR0FBR1IsdUJBQXNCLENBQUNILG1CQUFPLENBQUMsdUNBQTBCO0FBQ2hGLEdBQUcsQ0FBQ1ksYUFBYSxHQUFHWixtQkFBTyxDQUFDLGdHQUF1QjtBQUNuRCxHQUFHLENBQUNhLFdBQVcsR0FBR2IsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDL0MsR0FBRyxDQUFDYyxtQkFBbUIsR0FBR2QsbUJBQU8sQ0FBQyw4R0FBOEI7U0FDdkRHLHVCQUFzQixDQUFDWSxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDakIsT0FBTyxFQUFFaUIsR0FBRztJQUNoQixDQUFDO0FBQ0wsQ0FBQztBQUNELEdBQUcsQ0FBQ0Usa0JBQWtCO0FBQ3RCLEVBQUUsRUFBRUMsS0FBK0IsRUFBRSxFQUVwQztBQUNELEdBQUssQ0FBQ0csUUFBUSxHQUFHSCxNQUFrQyxJQUFJLENBQUU7U0FDaERLLHNCQUFzQixHQUFHLENBQUM7SUFDL0IsTUFBTSxDQUFDdEMsTUFBTSxDQUFDdUMsTUFBTSxDQUFDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLENBQWlCLG1CQUFHLENBQUM7UUFDaERDLFNBQVMsRUFBRSxJQUFJO0lBQ25CLENBQUM7QUFDTCxDQUFDO1NBQ1FDLGFBQWEsQ0FBQ0MsSUFBSSxFQUFFQyxNQUFNLEVBQUUsQ0FBQztJQUNsQyxFQUFFLEdBQUdELElBQUksQ0FBQ0UsVUFBVSxDQUFDLENBQUcsUUFBTUQsTUFBTSxFQUFFLENBQUM7UUFDbkMsTUFBTSxDQUFDRCxJQUFJO0lBQ2YsQ0FBQztJQUNELEdBQUssQ0FBQ0csUUFBUSxHQUFHQyxlQUFlLENBQUNKLElBQUk7SUFDckMsTUFBTSxFQUFFLENBQUMsRUFBRTdCLHVCQUF1QixFQUFFa0MsMEJBQTBCLENBQUUsR0FBV0YsTUFBUSxDQUFqQkYsTUFBTSxFQUFZLE9BQVRFLFFBQVEsS0FBTUgsSUFBSSxDQUFDTSxNQUFNLENBQUNILFFBQVEsQ0FBQ0ksTUFBTTtBQUN4SCxDQUFDO1NBQ1E5QyxlQUFlLENBQUN1QyxJQUFJLEVBQUVRLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxhQUFhLEVBQUUsQ0FBQztJQUM1RCxFQUFFLEVBQUVwQixLQUErQixFQUFFLHVCQU9wQyxNQUFNLENBQUM7UUFDSixNQUFNLENBQUMsS0FBSztJQUNoQixDQUFDO0FBQ0wsQ0FBQztTQUNRNUIsU0FBUyxDQUFDc0MsSUFBSSxFQUFFUSxNQUFNLEVBQUVTLGFBQWEsRUFBRSxDQUFDO0lBQzdDLEVBQUUsRUFBRTNCLEtBQStCLEVBQUUseUNBS3BDO0lBQ0QsTUFBTSxDQUFDVSxJQUFJO0FBQ2YsQ0FBQztTQUNRckMsU0FBUyxDQUFDcUMsSUFBSSxFQUFFUSxNQUFNLEVBQUUsQ0FBQztJQUM5QixFQUFFLEVBQUVsQixLQUErQixFQUFFLHlDQUtwQztJQUNELE1BQU0sQ0FBQ1UsSUFBSTtBQUNmLENBQUM7U0FDUUksZUFBZSxDQUFDSixJQUFJLEVBQUUsQ0FBQztJQUM1QixHQUFLLENBQUNxQixVQUFVLEdBQUdyQixJQUFJLENBQUNzQixPQUFPLENBQUMsQ0FBRztJQUNuQyxHQUFLLENBQUNDLFNBQVMsR0FBR3ZCLElBQUksQ0FBQ3NCLE9BQU8sQ0FBQyxDQUFHO0lBQ2xDLEVBQUUsRUFBRUQsVUFBVSxJQUFJLENBQUMsSUFBSUUsU0FBUyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ3BDdkIsSUFBSSxHQUFHQSxJQUFJLENBQUN3QixTQUFTLENBQUMsQ0FBQyxFQUFFSCxVQUFVLElBQUksQ0FBQyxHQUFHQSxVQUFVLEdBQUdFLFNBQVM7SUFDckUsQ0FBQztJQUNELE1BQU0sQ0FBQ3ZCLElBQUk7QUFDZixDQUFDO1NBQ1FwQyxXQUFXLENBQUNvQyxJQUFJLEVBQUUsQ0FBQztJQUN4QkEsSUFBSSxHQUFHSSxlQUFlLENBQUNKLElBQUk7SUFDM0IsTUFBTSxDQUFDQSxJQUFJLEtBQUtQLFFBQVEsSUFBSU8sSUFBSSxDQUFDRSxVQUFVLENBQUNULFFBQVEsR0FBRyxDQUFHO0FBQzlELENBQUM7U0FDUTVCLFdBQVcsQ0FBQ21DLElBQUksRUFBRSxDQUFDO0lBQ3hCLEVBQTRDO0lBQzVDLE1BQU0sQ0FBQ0QsYUFBYSxDQUFDQyxJQUFJLEVBQUVQLFFBQVE7QUFDdkMsQ0FBQztTQUNRM0IsV0FBVyxDQUFDa0MsSUFBSSxFQUFFLENBQUM7SUFDeEJBLElBQUksR0FBR0EsSUFBSSxDQUFDeUIsS0FBSyxDQUFDaEMsUUFBUSxDQUFDYyxNQUFNO0lBQ2pDLEVBQUUsR0FBR1AsSUFBSSxDQUFDRSxVQUFVLENBQUMsQ0FBRyxLQUFHRixJQUFJLEdBQUksQ0FBQyxHQUFPLE9BQUxBLElBQUk7SUFDMUMsTUFBTSxDQUFDQSxJQUFJO0FBQ2YsQ0FBQztTQUNRakMsVUFBVSxDQUFDMkQsR0FBRyxFQUFFLENBQUM7SUFDdEIsRUFBZ0U7SUFDaEUsRUFBRSxFQUFFQSxHQUFHLENBQUN4QixVQUFVLENBQUMsQ0FBRyxPQUFLd0IsR0FBRyxDQUFDeEIsVUFBVSxDQUFDLENBQUcsT0FBS3dCLEdBQUcsQ0FBQ3hCLFVBQVUsQ0FBQyxDQUFHLEtBQUcsTUFBTSxDQUFDLElBQUk7SUFDbEYsR0FBRyxDQUFDLENBQUM7UUFDRCxFQUE0RDtRQUM1RCxHQUFLLENBQUN5QixjQUFjLElBQUksQ0FBQyxFQUFFaEQsTUFBTSxFQUFFaUQsaUJBQWlCO1FBQ3BELEdBQUssQ0FBQ0MsUUFBUSxHQUFHLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHLEVBQUVDLGNBQWM7UUFDNUMsTUFBTSxDQUFDRSxRQUFRLENBQUNFLE1BQU0sS0FBS0osY0FBYyxJQUFJL0QsV0FBVyxDQUFDaUUsUUFBUSxDQUFDMUIsUUFBUTtJQUM5RSxDQUFDLENBQUMsS0FBSyxFQUFFNkIsQ0FBQyxFQUFFLENBQUM7UUFDVCxNQUFNLENBQUMsS0FBSztJQUNoQixDQUFDO0FBQ0wsQ0FBQztTQUNRaEUsYUFBYSxDQUFDaUUsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxDQUFDO0lBQzlDLEdBQUcsQ0FBQ0MsaUJBQWlCLEdBQUcsQ0FBRTtJQUMxQixHQUFLLENBQUNDLFlBQVksSUFBSSxDQUFDLEVBQUVwRCxXQUFXLEVBQUVxRCxhQUFhLENBQUNMLEtBQUs7SUFDekQsR0FBSyxDQUFDTSxhQUFhLEdBQUdGLFlBQVksQ0FBQ0csTUFBTTtJQUN6QyxHQUFLLENBQUNDLGNBQWMsSUFDbkJQLFVBQVUsS0FBS0QsS0FBSyxJQUFJLENBQUMsRUFBRWpELGFBQWEsRUFBRTBELGVBQWUsQ0FBQ0wsWUFBWSxFQUFFSCxVQUFVLElBQUksQ0FBRSxNQUN6RixFQUFzRTtJQUN0RUMsS0FBSztJQUNMQyxpQkFBaUIsR0FBR0gsS0FBSztJQUN6QixHQUFLLENBQUNVLE1BQU0sR0FBR3RGLE1BQU0sQ0FBQ3VGLElBQUksQ0FBQ0wsYUFBYTtJQUN4QyxFQUFFLEdBQUdJLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsS0FBSyxFQUFHLENBQUM7UUFDeEIsR0FBRyxDQUFDdEYsS0FBSyxHQUFHaUYsY0FBYyxDQUFDSyxLQUFLLEtBQUssQ0FBRTtRQUN2QyxHQUFLLENBQTBCUCxNQUFvQixHQUFwQkEsYUFBYSxDQUFDTyxLQUFLLEdBQTFDQyxNQUFNLEdBQWlCUixNQUFvQixDQUEzQ1EsTUFBTSxFQUFHQyxRQUFRLEdBQU1ULE1BQW9CLENBQWxDUyxRQUFRO1FBQ3pCLEVBQWlDO1FBQ2pDLEVBQTBEO1FBQzFELEdBQUcsQ0FBQ0MsUUFBUSxHQUFJLENBQUMsR0FBd0JILE1BQUssQ0FBM0JDLE1BQU0sR0FBRyxDQUFLLE9BQUcsQ0FBRSxHQUFTLE1BQUMsQ0FBUEQsS0FBSyxFQUFDLENBQUM7UUFDaEQsRUFBRSxFQUFFRSxRQUFRLEVBQUUsQ0FBQztZQUNYQyxRQUFRLEdBQUksR0FBdUJBLE1BQVEsRUFBNUJ6RixLQUFLLEdBQUcsQ0FBRyxLQUFHLENBQUUsR0FBQyxDQUFDLElBQVcsTUFBQyxDQUFWeUYsUUFBUSxFQUFDLENBQUM7UUFDakQsQ0FBQztRQUNELEVBQUUsRUFBRUYsTUFBTSxLQUFLRyxLQUFLLENBQUNDLE9BQU8sQ0FBQzNGLEtBQUssR0FBR0EsS0FBSyxHQUFHLENBQUM7WUFDMUNBLEtBQUs7UUFDVCxDQUFDO1FBQ0QsTUFBTSxFQUFFd0YsUUFBUSxJQUFJRixLQUFLLElBQUlMLGNBQWMsTUFDMUNMLGlCQUFpQixHQUFHQSxpQkFBaUIsQ0FBQ2dCLE9BQU8sQ0FBQ0gsUUFBUSxFQUFFRixNQUFNLEdBQUd2RixLQUFLLENBQUM2RixHQUFHLENBQzNFLEVBQXVEO1FBQ3ZELEVBQWtEO1FBQ2xELEVBQW9DO1FBQ3BDLFFBQVEsQ0FBUEMsT0FBTztZQUFHQyxNQUFNLENBQU5BLGtCQUFrQixDQUFDRCxPQUFPO1dBQ25DRSxJQUFJLENBQUMsQ0FBRyxNQUFJRCxrQkFBa0IsQ0FBQy9GLEtBQUssTUFBTSxDQUFHO0lBQ25ELENBQUMsR0FBRyxDQUFDO1FBQ0Q0RSxpQkFBaUIsR0FBRyxDQUFFLENBQUMsQ0FBbUM7O0lBRTlELEVBQXVFO0lBQ3ZFLEVBQWtEO0lBQ2xELENBQUM7SUFDRCxNQUFNLENBQUMsQ0FBQztRQUNKTyxNQUFNLEVBQU5BLE1BQU07UUFDTmMsTUFBTSxFQUFFckIsaUJBQWlCO0lBQzdCLENBQUM7QUFDTCxDQUFDO1NBQ1FzQixrQkFBa0IsQ0FBQ3ZCLEtBQUssRUFBRVEsTUFBTSxFQUFFLENBQUM7SUFDeEMsR0FBSyxDQUFDZ0IsYUFBYSxHQUFHLENBQUM7SUFDdkIsQ0FBQztJQUNEdEcsTUFBTSxDQUFDdUYsSUFBSSxDQUFDVCxLQUFLLEVBQUV5QixPQUFPLENBQUMsUUFBUSxDQUFQQyxHQUFHLEVBQUcsQ0FBQztRQUMvQixFQUFFLEdBQUdsQixNQUFNLENBQUNtQixRQUFRLENBQUNELEdBQUcsR0FBRyxDQUFDO1lBQ3hCRixhQUFhLENBQUNFLEdBQUcsSUFBSTFCLEtBQUssQ0FBQzBCLEdBQUc7UUFDbEMsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNLENBQUNGLGFBQWE7QUFDeEIsQ0FBQztTQUNRMUYsV0FBVyxDQUFDOEYsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRSxDQUFDO0lBQzNDLEVBQTRDO0lBQzVDLEdBQUcsQ0FBQ0MsSUFBSTtJQUNSLEdBQUcsQ0FBQ0MsV0FBVyxHQUFHLE1BQU0sQ0FBQ0gsSUFBSSxLQUFLLENBQVEsVUFBR0EsSUFBSSxJQUFJLENBQUMsRUFBRXJGLE1BQU0sRUFBRXlGLG9CQUFvQixDQUFDSixJQUFJO0lBQ3pGLEVBQTZEO0lBQzdELEVBQW1EO0lBQ25ELEdBQUssQ0FBQ0ssYUFBYSxHQUFHRixXQUFXLENBQUNHLEtBQUs7SUFDdkMsR0FBSyxDQUFDQyxrQkFBa0IsR0FBR0YsYUFBYSxHQUFHRixXQUFXLENBQUM3RCxNQUFNLENBQUMrRCxhQUFhLENBQUMsQ0FBQyxFQUFFOUQsTUFBTSxJQUFJNEQsV0FBVztJQUNwRyxHQUFLLENBQUNLLFFBQVEsR0FBR0Qsa0JBQWtCLENBQUNFLEtBQUssQ0FBQyxDQUFHO0lBQzdDLEVBQUUsR0FBR0QsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFFLEdBQUVGLEtBQUssZUFBZSxDQUFDO1FBQ3pDSSxPQUFPLENBQUNDLEtBQUssQ0FBRSxDQUFvQyxzQ0FBYyxNQUEyRSxDQUF2RlIsV0FBVyxFQUFDLENBQTJFO1FBQzVJLEdBQUssQ0FBQ1MsYUFBYSxJQUFJLENBQUMsRUFBRWpHLE1BQU0sRUFBRWtHLHdCQUF3QixDQUFDTixrQkFBa0I7UUFDN0VKLFdBQVcsSUFBSUUsYUFBYSxHQUFHQSxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUUsS0FBSU8sYUFBYTtJQUN6RSxDQUFDO0lBQ0QsRUFBMkQ7SUFDM0QsRUFBRSxHQUFHN0csVUFBVSxDQUFDb0csV0FBVyxHQUFHLENBQUM7UUFDM0IsTUFBTSxDQUFDRixTQUFTLEdBQUcsQ0FBQztZQUNoQkUsV0FBVztRQUNmLENBQUMsR0FBR0EsV0FBVztJQUNuQixDQUFDO0lBQ0QsR0FBRyxDQUFDLENBQUM7UUFDREQsSUFBSSxHQUFHLEdBQUcsQ0FBQ3BDLEdBQUcsQ0FBQ3FDLFdBQVcsQ0FBQ2pFLFVBQVUsQ0FBQyxDQUFHLE1BQUk2RCxNQUFNLENBQUNlLE1BQU0sR0FBR2YsTUFBTSxDQUFDNUQsUUFBUSxFQUFFLENBQVU7SUFDNUYsQ0FBQyxDQUFDLEtBQUssRUFBRTZCLENBQUMsRUFBRSxDQUFDO1FBQ1QsRUFBa0Q7UUFDbERrQyxJQUFJLEdBQUcsR0FBRyxDQUFDcEMsR0FBRyxDQUFDLENBQUcsSUFBRSxDQUFVO0lBQ2xDLENBQUM7SUFDRCxHQUFHLENBQUMsQ0FBQztRQUNELEdBQUssQ0FBQ2lELFFBQVEsR0FBRyxHQUFHLENBQUNqRCxHQUFHLENBQUNxQyxXQUFXLEVBQUVELElBQUk7UUFDMUNhLFFBQVEsQ0FBQzVFLFFBQVEsSUFBSSxDQUFDLEVBQUVoQyx1QkFBdUIsRUFBRWtDLDBCQUEwQixDQUFDMEUsUUFBUSxDQUFDNUUsUUFBUTtRQUM3RixHQUFHLENBQUM2RSxjQUFjLEdBQUcsQ0FBRTtRQUN2QixFQUFFLEdBQUcsQ0FBQyxFQUFFcEcsVUFBVSxFQUFFcUcsY0FBYyxDQUFDRixRQUFRLENBQUM1RSxRQUFRLEtBQUs0RSxRQUFRLENBQUNHLFlBQVksSUFBSWpCLFNBQVMsRUFBRSxDQUFDO1lBQzFGLEdBQUssQ0FBQzlCLEtBQUssSUFBSSxDQUFDLEVBQUVyRCxZQUFZLEVBQUVxRyxzQkFBc0IsQ0FBQ0osUUFBUSxDQUFDRyxZQUFZO1lBQzVFLEdBQUssQ0FBd0JsSCxHQUEwRCxHQUExREEsYUFBYSxDQUFDK0csUUFBUSxDQUFDNUUsUUFBUSxFQUFFNEUsUUFBUSxDQUFDNUUsUUFBUSxFQUFFZ0MsS0FBSyxHQUE5RXNCLE1BQU0sR0FBZXpGLEdBQTBELENBQS9FeUYsTUFBTSxFQUFHZCxNQUFNLEdBQU0zRSxHQUEwRCxDQUF0RTJFLE1BQU07WUFDdkIsRUFBRSxFQUFFYyxNQUFNLEVBQUUsQ0FBQztnQkFDVHVCLGNBQWMsSUFBSSxDQUFDLEVBQUVyRyxNQUFNLEVBQUV5RixvQkFBb0IsQ0FBQyxDQUFDO29CQUMvQ2pFLFFBQVEsRUFBRXNELE1BQU07b0JBQ2hCMkIsSUFBSSxFQUFFTCxRQUFRLENBQUNLLElBQUk7b0JBQ25CakQsS0FBSyxFQUFFdUIsa0JBQWtCLENBQUN2QixLQUFLLEVBQUVRLE1BQU07Z0JBQzNDLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztRQUNELEVBQW9FO1FBQ3BFLEdBQUssQ0FBQzBDLFlBQVksR0FBR04sUUFBUSxDQUFDaEQsTUFBTSxLQUFLbUMsSUFBSSxDQUFDbkMsTUFBTSxHQUFHZ0QsUUFBUSxDQUFDZixJQUFJLENBQUN2QyxLQUFLLENBQUNzRCxRQUFRLENBQUNoRCxNQUFNLENBQUN4QixNQUFNLElBQUl3RSxRQUFRLENBQUNmLElBQUk7UUFDbEgsTUFBTSxDQUFDQyxTQUFTLEdBQUcsQ0FBQztZQUNoQm9CLFlBQVk7WUFDWkwsY0FBYyxJQUFJSyxZQUFZO1FBQ2xDLENBQUMsR0FBR0EsWUFBWTtJQUNwQixDQUFDLENBQUMsS0FBSyxFQUFFQyxFQUFFLEVBQUUsQ0FBQztRQUNWLE1BQU0sQ0FBQ3JCLFNBQVMsR0FBRyxDQUFDO1lBQ2hCRSxXQUFXO1FBQ2YsQ0FBQyxHQUFHQSxXQUFXO0lBQ25CLENBQUM7QUFDTCxDQUFDO1NBQ1FvQixXQUFXLENBQUM3RCxHQUFHLEVBQUUsQ0FBQztJQUN2QixHQUFLLENBQUNLLE1BQU0sSUFBSSxDQUFDLEVBQUVwRCxNQUFNLEVBQUVpRCxpQkFBaUI7SUFDNUMsTUFBTSxDQUFDRixHQUFHLENBQUN4QixVQUFVLENBQUM2QixNQUFNLElBQUlMLEdBQUcsQ0FBQ0YsU0FBUyxDQUFDTyxNQUFNLENBQUN4QixNQUFNLElBQUltQixHQUFHO0FBQ3RFLENBQUM7U0FDUThELFlBQVksQ0FBQ3pCLE1BQU0sRUFBRXJDLEdBQUcsRUFBRStELEVBQUUsRUFBRSxDQUFDO0lBQ3BDLEVBQXNEO0lBQ3RELEVBQWtEO0lBQ2xELEdBQUcsQ0FBOEJ4SCxHQUE4QixrQkFBOUJBLFdBQVcsQ0FBQzhGLE1BQU0sRUFBRXJDLEdBQUcsRUFBRSxJQUFJLE9BQXpEMkQsWUFBWSxHQUFnQnBILEdBQThCLEtBQTVDeUgsVUFBVSxHQUFJekgsR0FBOEI7SUFDL0QsR0FBSyxDQUFDOEQsTUFBTSxJQUFJLENBQUMsRUFBRXBELE1BQU0sRUFBRWlELGlCQUFpQjtJQUM1QyxHQUFLLENBQUMrRCxhQUFhLEdBQUdOLFlBQVksQ0FBQ25GLFVBQVUsQ0FBQzZCLE1BQU07SUFDcEQsR0FBSyxDQUFDNkQsV0FBVyxHQUFHRixVQUFVLElBQUlBLFVBQVUsQ0FBQ3hGLFVBQVUsQ0FBQzZCLE1BQU07SUFDOURzRCxZQUFZLEdBQUdFLFdBQVcsQ0FBQ0YsWUFBWTtJQUN2Q0ssVUFBVSxHQUFHQSxVQUFVLEdBQUdILFdBQVcsQ0FBQ0csVUFBVSxJQUFJQSxVQUFVO0lBQzlELEdBQUssQ0FBQ0csV0FBVyxHQUFHRixhQUFhLEdBQUdOLFlBQVksR0FBR3hILFdBQVcsQ0FBQ3dILFlBQVk7SUFDM0UsR0FBSyxDQUFDUyxVQUFVLEdBQUdMLEVBQUUsR0FBR0YsV0FBVyxDQUFDdEgsV0FBVyxDQUFDOEYsTUFBTSxFQUFFMEIsRUFBRSxLQUFLQyxVQUFVLElBQUlMLFlBQVk7SUFDekYsTUFBTSxDQUFDLENBQUM7UUFDSjNELEdBQUcsRUFBRW1FLFdBQVc7UUFDaEJKLEVBQUUsRUFBRUcsV0FBVyxHQUFHRSxVQUFVLEdBQUdqSSxXQUFXLENBQUNpSSxVQUFVO0lBQ3pELENBQUM7QUFDTCxDQUFDO1NBQ1FDLG1CQUFtQixDQUFDNUYsUUFBUSxFQUFFNkYsS0FBSyxFQUFFLENBQUM7SUFDM0MsR0FBSyxDQUFDQyxhQUFhLElBQUksQ0FBQyxFQUFFOUgsdUJBQXVCLEVBQUUrSCx1QkFBdUIsRUFBRSxDQUFDLEVBQUUxSCxvQkFBb0IsRUFBRTJILG1CQUFtQixDQUFDaEcsUUFBUTtJQUNqSSxFQUFFLEVBQUU4RixhQUFhLEtBQUssQ0FBTSxTQUFJQSxhQUFhLEtBQUssQ0FBUyxVQUFFLENBQUM7UUFDMUQsTUFBTSxDQUFDOUYsUUFBUTtJQUNuQixDQUFDO0lBQ0QsRUFBMkM7SUFDM0MsRUFBRSxHQUFHNkYsS0FBSyxDQUFDbEMsUUFBUSxDQUFDbUMsYUFBYSxHQUFHLENBQUM7UUFDakMsRUFBaUQ7UUFDakRELEtBQUssQ0FBQ0ksSUFBSSxDQUFDLFFBQVEsQ0FBUEMsSUFBSSxFQUFHLENBQUM7WUFDaEIsRUFBRSxHQUFHLENBQUMsRUFBRXpILFVBQVUsRUFBRXFHLGNBQWMsQ0FBQ29CLElBQUksTUFBTSxDQUFDLEVBQUVwSCxXQUFXLEVBQUVxRCxhQUFhLENBQUMrRCxJQUFJLEVBQUVDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDTixhQUFhLEdBQUcsQ0FBQztnQkFDdEc5RixRQUFRLEdBQUdrRyxJQUFJO2dCQUNmLE1BQU0sQ0FBQyxJQUFJO1lBQ2YsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxFQUFFLENBQUMsRUFBRWxJLHVCQUF1QixFQUFFK0gsdUJBQXVCLENBQUMvRixRQUFRO0FBQ3hFLENBQUM7QUFDRCxHQUFLLENBQUNxRyx1QkFBdUIsR0FBR2xILE1BQStHLElBQUksQ0FPaEo7QUFDSCxHQUFLLENBQUMySCxrQkFBa0IsR0FBR0MsTUFBTSxDQUFDLENBQW9CO1NBQzdDQyxVQUFVLENBQUN6RixHQUFHLEVBQUUwRixRQUFRLEVBQUUsQ0FBQztJQUNoQyxNQUFNLENBQUNDLEtBQUssQ0FBQzNGLEdBQUcsRUFBRSxDQUFDO1FBQ2YsRUFBc0U7UUFDdEUsRUFBeUQ7UUFDekQsRUFBRTtRQUNGLEVBQW9FO1FBQ3BFLEVBQVk7UUFDWixFQUF5RTtRQUN6RSxFQUFFO1FBQ0YsRUFBaUU7UUFDakUsRUFBc0U7UUFDdEUsRUFBOEM7UUFDOUMsRUFBMEM7UUFDMUM0RixXQUFXLEVBQUUsQ0FBYTtJQUM5QixDQUFDLEVBQUVDLElBQUksQ0FBQyxRQUFRLENBQVBDLEdBQUcsRUFBRyxDQUFDO1FBQ1osRUFBRSxHQUFHQSxHQUFHLENBQUNDLEVBQUUsRUFBRSxDQUFDO1lBQ1YsRUFBRSxFQUFFTCxRQUFRLEdBQUcsQ0FBQyxJQUFJSSxHQUFHLENBQUNFLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDcEMsTUFBTSxDQUFDUCxVQUFVLENBQUN6RixHQUFHLEVBQUUwRixRQUFRLEdBQUcsQ0FBQztZQUN2QyxDQUFDO1lBQ0QsRUFBRSxFQUFFSSxHQUFHLENBQUNFLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztnQkFDckIsTUFBTSxDQUFDRixHQUFHLENBQUNHLElBQUksR0FBR0osSUFBSSxDQUFDLFFBQVEsQ0FBUEssSUFBSSxFQUFHLENBQUM7b0JBQzVCLEVBQUUsRUFBRUEsSUFBSSxDQUFDQyxRQUFRLEVBQUUsQ0FBQzt3QkFDaEIsTUFBTSxDQUFDLENBQUM7NEJBQ0pBLFFBQVEsRUFBRVosa0JBQWtCO3dCQUNoQyxDQUFDO29CQUNMLENBQUM7b0JBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQ3BILEtBQUssQ0FBRSxDQUEyQjtnQkFDaEQsQ0FBQztZQUNMLENBQUM7WUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDQSxLQUFLLENBQUUsQ0FBMkI7UUFDaEQsQ0FBQztRQUNELE1BQU0sQ0FBQzJILEdBQUcsQ0FBQ0csSUFBSTtJQUNuQixDQUFDO0FBQ0wsQ0FBQztTQUNRRyxhQUFhLENBQUNDLFFBQVEsRUFBRUMsY0FBYyxFQUFFQyxhQUFhLEVBQUVDLFlBQVksRUFBRSxDQUFDO0lBQzNFLEdBQUssQ0FBdUIsR0FBdUMsR0FBdkMsR0FBRyxDQUFDcEcsR0FBRyxDQUFDaUcsUUFBUSxFQUFFckIsTUFBTSxDQUFDeUIsUUFBUSxDQUFDbkUsSUFBSSxHQUFwRG9FLFFBQVEsR0FBTSxHQUF1QyxDQUEzRHBFLElBQUk7SUFDWixFQUFFLEVBQUVpRSxhQUFhLENBQUNHLFFBQVEsTUFBTXRILFNBQVMsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sQ0FBQ21ILGFBQWEsQ0FBQ0csUUFBUTtJQUNqQyxDQUFDO0lBQ0QsTUFBTSxDQUFDSCxhQUFhLENBQUNHLFFBQVEsSUFBSWpCLFVBQVUsQ0FBQ1ksUUFBUSxFQUFFQyxjQUFjLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRUssS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7UUFDeEYsRUFBcUU7UUFDckUsRUFBb0U7UUFDcEUsRUFBUTtRQUNSLEVBQUUsR0FBR04sY0FBYyxFQUFFLENBQUM7YUFDakIsQ0FBQyxFQUFFM0osWUFBWSxFQUFFa0ssY0FBYyxDQUFDRCxHQUFHO1FBQ3hDLENBQUM7UUFDRCxLQUFLLENBQUNBLEdBQUc7SUFDYixDQUFDLEVBQUVmLElBQUksQ0FBQyxRQUFRLENBQVBLLElBQUksRUFBRyxDQUFDO1FBQ2IsRUFBRSxHQUFHTSxZQUFZLElBdFR6QixDQUFhLGlCQXNUeUMsQ0FBWSxhQUFFLENBQUM7WUFDekQsTUFBTSxDQUFDRCxhQUFhLENBQUNHLFFBQVE7UUFDakMsQ0FBQztRQUNELE1BQU0sQ0FBQ1IsSUFBSTtJQUNmLENBQUMsRUFBRVMsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7UUFDYixNQUFNLENBQUNMLGFBQWEsQ0FBQ0csUUFBUTtRQUM3QixLQUFLLENBQUNFLEdBQUc7SUFDYixDQUFDO0FBQ0wsQ0FBQztJQUNLRSxNQUFNLGlCQUFaLFFBQVE7YUFBRkEsTUFBTSxDQUNJckksU0FBUSxFQUFFZ0MsTUFBSyxFQUFFc0QsR0FBRSxFQUFFLEtBQTJKO1lBQXpKZ0QsWUFBWSxHQUFkLEtBQTJKLENBQXpKQSxZQUFZLEVBQUdDLFVBQVUsR0FBM0IsS0FBMkosQ0FBMUlBLFVBQVUsRUFBR0MsR0FBRyxHQUFqQyxLQUEySixDQUE3SEEsR0FBRyxFQUFHQyxPQUFPLEdBQTNDLEtBQTJKLENBQXZIQSxPQUFPLEVBQUdDLFNBQVMsR0FBdkQsS0FBMkosQ0FBN0dBLFNBQVMsRUFBR1AsR0FBRyxHQUE3RCxLQUEySixDQUFqR0EsR0FBRyxFQUFHUSxZQUFZLEdBQTVFLEtBQTJKLENBQTNGQSxZQUFZLEVBQUdDLFVBQVUsR0FBekYsS0FBMkosQ0FBNUVBLFVBQVUsRUFBR3ZJLE1BQU0sR0FBbEcsS0FBMkosQ0FBL0RBLE1BQU0sRUFBR0MsT0FBTyxHQUE1RyxLQUEySixDQUF0REEsT0FBTyxFQUFHUSxhQUFhLEdBQTVILEtBQTJKLENBQTVDQSxhQUFhLEVBQUdQLGFBQWEsR0FBNUksS0FBMkosQ0FBNUJBLGFBQWEsRUFBR3NJLFNBQVMsR0FBeEosS0FBMkosQ0FBWkEsU0FBUzs7OEJBRHZMUixNQUFNO1FBRUosRUFBb0I7UUFDcEIsSUFBSSxDQUFDUyxHQUFHLEdBQUcsQ0FBQztRQUNaLENBQUM7UUFDRCxFQUErQztRQUMvQyxJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFDO1FBQ1osQ0FBQztRQUNELEVBQTBDO1FBQzFDLElBQUksQ0FBQ0MsR0FBRyxHQUFHLENBQUM7UUFDWixDQUFDO1FBQ0QsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztRQUNiLElBQUksQ0FBQ0MsVUFBVSxHQUFHLFFBQ3pCLENBRDBCQyxDQUFDLEVBQUcsQ0FBQztZQUNwQixHQUFLLENBQUNDLEtBQUssR0FBR0QsQ0FBQyxDQUFDQyxLQUFLO1lBQ3JCLEVBQUUsR0FBR0EsS0FBSyxFQUFFLENBQUM7Z0JBQ1QsRUFBNkM7Z0JBQzdDLEVBQXNEO2dCQUN0RCxFQUFrQztnQkFDbEMsRUFBRTtnQkFDRixFQUFvRTtnQkFDcEUsRUFBNEI7Z0JBQzVCLEVBQTREO2dCQUM1RCxFQUFrRjtnQkFDbEYsRUFBZ0Q7Z0JBQ2hELEdBQUssQ0FBR3BKLFFBQVEsU0FBUkEsUUFBUSxFQUFHZ0MsS0FBSyxTQUFMQSxLQUFLO3NCQUNuQnFILFdBQVcsQ0FBQyxDQUFjLGdCQUFHLENBQUMsRUFBRTdLLE1BQU0sRUFBRXlGLG9CQUFvQixDQUFDLENBQUM7b0JBQy9EakUsUUFBUSxFQUFFdEMsV0FBVyxDQUFDc0MsUUFBUTtvQkFDOUJnQyxLQUFLLEVBQUxBLEtBQUs7Z0JBQ1QsQ0FBQyxJQUFJLENBQUMsRUFBRXhELE1BQU0sRUFBRThLLE1BQU07Z0JBQ3RCLE1BQU07WUFDVixDQUFDO1lBQ0QsRUFBRSxHQUFHRixLQUFLLENBQUNHLEdBQUcsRUFBRSxDQUFDO2dCQUNiLE1BQU07WUFDVixDQUFDO1lBQ0QsR0FBRyxDQUFDQyxZQUFZO1lBQ2hCLEdBQUssQ0FBR2pJLEdBQUcsR0FBMkI2SCxLQUFLLENBQW5DN0gsR0FBRyxFQUFHK0QsRUFBRSxHQUFzQjhELEtBQUssQ0FBN0I5RCxFQUFFLEVBQUdtRSxPQUFPLEdBQVlMLEtBQUssQ0FBeEJLLE9BQU8sRUFBR0MsR0FBRyxHQUFNTixLQUFLLENBQWRNLEdBQUc7WUFDaEMsRUFBRSxFQUFFdkssS0FBcUMsRUFBRSxVQXVCMUM7a0JBQ0k4SixJQUFJLEdBQUdTLEdBQUc7WUFDZixHQUFLLENBQUcxSixTQUFRLElBQU8sQ0FBQyxFQUFFdEIsaUJBQWlCLEVBQUUwTCxnQkFBZ0IsQ0FBQzdJLEdBQUcsRUFBekR2QixRQUFRO1lBQ2hCLEVBQWdEO1lBQ2hELEVBQXlEO1lBQ3pELEVBQUUsUUFBT3FLLEtBQUssSUFBSS9FLEVBQUUsV0FBVVgsTUFBTSxJQUFJM0UsU0FBUSxXQUFVQSxRQUFRLEVBQUUsQ0FBQztnQkFDakUsTUFBTTtZQUNWLENBQUM7WUFDRCxFQUF1RDtZQUN2RCxFQUF3RDtZQUN4RCxFQUFFLFFBQU9zSyxJQUFJLFdBQVVBLElBQUksQ0FBQ2xCLEtBQUssR0FBRyxDQUFDO2dCQUNqQyxNQUFNO1lBQ1YsQ0FBQztrQkFDSW1CLE1BQU0sQ0FBQyxDQUFjLGVBQUVoSixHQUFHLEVBQUUrRCxFQUFFLEVBQUVwSSxNQUFNLENBQUN1QyxNQUFNLENBQUMsQ0FBQztZQUNwRCxDQUFDLEVBQUVnSyxPQUFPLEVBQUUsQ0FBQztnQkFDVGUsT0FBTyxFQUFFZixPQUFPLENBQUNlLE9BQU8sVUFBU0MsUUFBUTtnQkFDekNwSyxNQUFNLEVBQUVvSixPQUFPLENBQUNwSixNQUFNLFVBQVNTLGFBQWE7WUFDaEQsQ0FBQyxHQUFHMEksWUFBWTtRQUNwQixDQUFDO1FBQ0QsRUFBdUM7UUFDdkMsSUFBSSxDQUFDMUgsS0FBSyxJQUFJLENBQUMsRUFBRTlELHVCQUF1QixFQUFFK0gsdUJBQXVCLENBQUMvRixTQUFRO1FBQzFFLEVBQTZDO1FBQzdDLElBQUksQ0FBQzBLLFVBQVUsR0FBRyxDQUFDO1FBQ25CLENBQUM7UUFDRCxFQUFvRDtRQUNwRCxFQUF3RDtRQUN4RCxFQUFrQztRQUNsQyxFQUFFLEVBQUUxSyxTQUFRLEtBQUssQ0FBUyxVQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDMEssVUFBVSxDQUFDLElBQUksQ0FBQzVJLEtBQUssSUFBSSxDQUFDO2dCQUMzQjRHLFNBQVMsRUFBVEEsU0FBUztnQkFDVGlDLE9BQU8sRUFBRSxJQUFJO2dCQUNiQyxLQUFLLEVBQUV0QyxZQUFZO2dCQUNuQkgsR0FBRyxFQUFIQSxHQUFHO2dCQUNIMEMsT0FBTyxFQUFFdkMsWUFBWSxJQUFJQSxZQUFZLENBQUN1QyxPQUFPO2dCQUM3Q0MsT0FBTyxFQUFFeEMsWUFBWSxJQUFJQSxZQUFZLENBQUN3QyxPQUFPO1lBQ2pELENBQUM7UUFDTCxDQUFDO1FBQ0QsSUFBSSxDQUFDSixVQUFVLENBQUMsQ0FBTyxVQUFJLENBQUM7WUFDeEJoQyxTQUFTLEVBQUVGLEdBQUc7WUFDZHVDLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFDbkIsQ0FBQztRQUNELEVBQTRDO1FBQzVDLEVBQWdGO1FBQ2hGLElBQUksQ0FBQ0MsTUFBTSxHQUFHM0MsTUFBTSxDQUFDMkMsTUFBTTtRQUMzQixJQUFJLENBQUN6QyxVQUFVLEdBQUdBLFVBQVU7UUFDNUIsSUFBSSxDQUFDdkksUUFBUSxHQUFHQSxTQUFRO1FBQ3hCLElBQUksQ0FBQ2dDLEtBQUssR0FBR0EsTUFBSztRQUNsQixFQUE4RDtRQUM5RCxFQUFrRDtRQUNsRCxHQUFLLENBQUNpSixpQkFBaUIsSUFBSSxDQUFDLEVBQUV4TSxVQUFVLEVBQUVxRyxjQUFjLENBQUM5RSxTQUFRLEtBQUs4SixJQUFJLENBQUNvQixhQUFhLENBQUNDLFVBQVU7UUFDbkcsSUFBSSxDQUFDeEcsTUFBTSxHQUFHc0csaUJBQWlCLEdBQUdqTCxTQUFRLEdBQUdzRixHQUFFO1FBQy9DLElBQUksQ0FBQ2hHLFFBQVEsR0FBR0EsUUFBUTtRQUN4QixJQUFJLENBQUM4TCxHQUFHLEdBQUd6QyxZQUFZO1FBQ3ZCLElBQUksQ0FBQzBDLEdBQUcsR0FBRyxJQUFJO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc3QyxPQUFPO1FBQ3ZCLEVBQTZEO1FBQzdELEVBQTBCO1FBQzFCLElBQUksQ0FBQzRCLEtBQUssR0FBRyxJQUFJO1FBQ2pCLElBQUksQ0FBQ3pCLFVBQVUsR0FBR0EsVUFBVTtRQUM1QixJQUFJLENBQUMyQyxPQUFPLE1BQU16QixJQUFJLENBQUNvQixhQUFhLENBQUNNLElBQUksSUFBSTFCLElBQUksQ0FBQ29CLGFBQWEsQ0FBQ08sR0FBRyxJQUFJM0IsSUFBSSxDQUFDb0IsYUFBYSxDQUFDUSxNQUFNLEtBQUs1QixJQUFJLENBQUNvQixhQUFhLENBQUNTLEdBQUcsS0FBS1YsaUJBQWlCLEtBQUtuQixJQUFJLENBQUM5QixRQUFRLENBQUM0RCxNQUFNLEtBQUt6TSxLQUErQjtRQUM5TSxJQUFJLENBQUMwSixTQUFTLEtBQUtBLFNBQVM7UUFDNUIsSUFBSSxDQUFDaUQsY0FBYyxHQUFHLEtBQUs7UUFDM0IsRUFBRSxFQUFFM00sS0FBK0IsRUFBRSxFQU1wQztRQUNELEVBQUUsRUFBRSxJQUE2QixFQUFFLENBQUM7WUFDaEMsRUFBa0U7WUFDbEUsRUFBNEM7WUFDNUMsRUFBRSxFQUFFbUcsR0FBRSxDQUFDbkYsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBSSxLQUFFLENBQUM7Z0JBQzNCLEVBQTJEO2dCQUMzRCxFQUE0RDtnQkFDNUQsR0FBSyxDQUFDc0osUUFBTyxHQUFHLENBQUM7b0JBQ2JwSixNQUFNLEVBQU5BLE1BQU07Z0JBQ1YsQ0FBQztnQkFDRG9KLFFBQU8sQ0FBQ3VDLGtCQUFrQixHQUFHMUcsR0FBRSxLQUFLdEYsU0FBUTtnQkFDNUMsSUFBSSxDQUFDcUosV0FBVyxDQUFDLENBQWMsZ0JBQUcsQ0FBQyxFQUFFN0ssTUFBTSxFQUFFeUYsb0JBQW9CLENBQUMsQ0FBQztvQkFDL0RqRSxRQUFRLEVBQUV0QyxXQUFXLENBQUNzQyxTQUFRO29CQUM5QmdDLEtBQUssRUFBTEEsTUFBSztnQkFDVCxDQUFDLElBQUksQ0FBQyxFQUFFeEQsTUFBTSxFQUFFOEssTUFBTSxJQUFJRyxRQUFPO1lBQ3JDLENBQUM7WUFDRGxELE1BQU0sQ0FBQzBGLGdCQUFnQixDQUFDLENBQVUsV0FBRSxJQUFJLENBQUMvQyxVQUFVO1lBQ25ELEVBQTJEO1lBQzNELEVBQW1EO1lBQ25ELEVBQUUsRUFBRS9KLEtBQXFDLEVBQUUsRUFJMUM7UUFDTCxDQUFDOztpQkF2SkhrSixNQUFNOztZQXlKUjhELEdBQU0sRUFBTkEsQ0FBTTttQkFBTkEsUUFBUSxDQUFSQSxNQUFNLEdBQUcsQ0FBQztnQkFDTjVGLE1BQU0sQ0FBQ3lCLFFBQVEsQ0FBQ21FLE1BQU07WUFDMUIsQ0FBQzs7O1lBQ0QsRUFFQzs7R0FBQSxHQUFDQyxHQUFJLEVBQUpBLENBQUk7bUJBQUpBLFFBQVEsQ0FBUkEsSUFBSSxHQUFHLENBQUM7Z0JBQ043RixNQUFNLENBQUNDLE9BQU8sQ0FBQzRGLElBQUk7WUFDdkIsQ0FBQzs7O1lBQ0QsRUFLQzs7Ozs7R0FBQSxHQUFDQyxHQUFJLEVBQUpBLENBQUk7bUJBQUpBLFFBQVEsQ0FBUkEsSUFBSSxDQUFDOUssR0FBRyxFQUFFK0QsRUFBRSxFQUFFbUUsS0FDZixFQUFFLENBQUM7b0JBRFlBLE9BQU8sR0FBUEEsS0FDZixjQUR5QixDQUFDO2dCQUMzQixDQUFDLEdBRGVBLEtBQ2Y7Z0JBQ0csRUFBRSxFQUFFdEssS0FBcUMsRUFBRSxFQWExQzs7c0JBQ2dCa0csWUFBWSxDQUFDLElBQUksRUFBRTlELEdBQUcsRUFBRStELEVBQUUsR0FBeEMvRCxHQUFHLE9BQUhBLEdBQUcsRUFBRytELEVBQUUsT0FBRkEsRUFBRTtnQkFDWCxNQUFNLENBQUMsSUFBSSxDQUFDaUYsTUFBTSxDQUFDLENBQVcsWUFBRWhKLEdBQUcsRUFBRStELEVBQUUsRUFBRW1FLE9BQU87WUFDcEQsQ0FBQzs7O1lBQ0QsRUFLQzs7Ozs7R0FBQSxHQUFDeEcsR0FBTyxFQUFQQSxDQUFPO21CQUFQQSxRQUFRMUIsQ0FBUjBCLE9BQU8sQ0FBQzFCLEdBQUcsRUFBRStELEVBQUUsRUFBRW1FLEtBQ2xCLEVBQUUsQ0FBQztvQkFEZUEsT0FBTyxHQUFQQSxLQUNsQixjQUQ0QixDQUFDO2dCQUM5QixDQUFDLEdBRGtCQSxLQUNsQjs7c0JBQ29CcEUsWUFBWSxDQUFDLElBQUksRUFBRTlELEdBQUcsRUFBRStELEVBQUUsR0FBeEMvRCxHQUFHLE9BQUhBLEdBQUcsRUFBRytELEVBQUUsT0FBRkEsRUFBRTtnQkFDWCxNQUFNLENBQUMsSUFBSSxDQUFDaUYsTUFBTSxDQUFDLENBQWMsZUFBRWhKLEdBQUcsRUFBRStELEVBQUUsRUFBRW1FLE9BQU87WUFDdkQsQ0FBQzs7O1lBQ0tjLEdBQU0sRUFBTkEsQ0FBTTttQkFBWixRQUFRLENBQUZBLE1BQU0sQ0FBQytCLE1BQU0sRUFBRS9LLEdBQUcsRUFBRStELEVBQUUsRUFBRW1FLE9BQU8sRUFBRUQsWUFBWTswRUFBbkQsUUFBUSxXQUE2QyxDQUFDO3dCQUs1QytDLGlCQUFpQixFQU1qQkMsVUFBVSxFQU1OQyxRQUFRLEVBQ1JDLGdCQUFnQixFQU9sQkMsV0FBVyxFQUlQQyxHQUFHLEVBVUxsTSxjQUFjLEVBT05tTSxZQUFZLEVBbUJ0QnJDLE9BQU8sRUFDVHNDLFVBQVUsRUFPVkMsU0FBUyxFQUVYQyxZQUFZLEVBZ0JaQyxNQUFNLEVBQ0pqTixRQUFRLEVBQUdnQyxLQUFLLEVBSWxCNkQsS0FBSyxFQUFFcUgsUUFBUSxFQXVCZjNILFVBQVUsRUFRQTRILGNBQWMsRUEyQnRCQyxNQUFNLEVBMkJOdEwsS0FBSyxFQUVEMkssU0FBUSxFQUNSMUssVUFBVSxFQUNWc0wsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLGlCQUFpQixFQUNqQjFJLGNBQWMsRUFHVjJJLGFBQWEsRUFxQm5CWixHQUFHLEVBQUVhLElBQUksRUFDVEMsU0FBUyxFQUNQbEosS0FBSyxFQUFHb0csS0FBSyxFQUFHQyxPQUFPLEVBQUdDLE9BQU8sRUFJekI2QyxXQUFXLEVBS1BDLFVBQVUsRUFFSEMsTUFBTSxFQUFPQyxLQUFLLEVBVS9CQyxhQUFhLEVBb0JuQkMsbUJBQW1CLEVBQ3JCQyxPQUFPLEVBQ0xDLFlBQVksRUFDWkMsV0FBVzs7OztvQ0FqUWhCdlEsVUFBVSxDQUFDMkQsR0FBRzs7OztnQ0FDZmdGLE1BQU0sQ0FBQ3lCLFFBQVEsQ0FBQ25FLElBQUksR0FBR3RDLEdBQUc7NkRBQ25CLEtBQUs7O2dDQUVWZ0wsaUJBQWlCLEdBQUc5QyxPQUFPLENBQUMyRSxFQUFFLElBQUkzRSxPQUFPLENBQUN1QyxrQkFBa0IsSUFBSS9MLGVBQWUsQ0FBQ3NCLEdBQUcsTUFBTXRCLGVBQWUsQ0FBQ3FGLEVBQUU7Z0NBQ2pILEVBQXlEO2dDQUN6RCxFQUE0RDtnQ0FDNUQsRUFBRSxFQUFFbUUsT0FBTyxDQUFDMkUsRUFBRSxFQUFFLENBQUM7b0NBQ2IsSUFBSSxDQUFDN0MsT0FBTyxHQUFHLElBQUk7Z0NBQ3ZCLENBQUM7Z0NBQ0tpQixVQUFVLEdBQUcsSUFBSSxDQUFDbk0sTUFBTTt3Q0FDSzs7OztnQ0FDL0IsSUFBSSxDQUFDQSxNQUFNLEdBQUdvSixPQUFPLENBQUNwSixNQUFNLEtBQUssS0FBSyxHQUFHLElBQUksQ0FBQ1MsYUFBYSxHQUFHMkksT0FBTyxDQUFDcEosTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTTtnQ0FDM0YsRUFBRSxFQUFFLE1BQU0sQ0FBQ29KLE9BQU8sQ0FBQ3BKLE1BQU0sS0FBSyxDQUFXLFlBQUUsQ0FBQztvQ0FDeENvSixPQUFPLENBQUNwSixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO2dDQUNoQyxDQUFDO2dDQUNLb00sUUFBUSxJQUFJLENBQUMsRUFBRS9OLGlCQUFpQixFQUFFMEwsZ0JBQWdCLENBQUMzTSxXQUFXLENBQUM2SCxFQUFFLElBQUkzSCxXQUFXLENBQUMySCxFQUFFLElBQUlBLEVBQUU7Z0NBQ3pGb0gsZ0JBQWdCLElBQUksQ0FBQyxFQUFFcE8sb0JBQW9CLEVBQUVrQyxtQkFBbUIsQ0FBQ2lNLFFBQVEsQ0FBQ3pNLFFBQVEsRUFBRSxJQUFJLENBQUNNLE9BQU87Z0NBQ3RHLEVBQUUsRUFBRW9NLGdCQUFnQixDQUFDak0sY0FBYyxFQUFFLENBQUM7b0NBQ2xDLElBQUksQ0FBQ0osTUFBTSxHQUFHcU0sZ0JBQWdCLENBQUNqTSxjQUFjO29DQUM3Q2dNLFFBQVEsQ0FBQ3pNLFFBQVEsR0FBR3RDLFdBQVcsQ0FBQytPLFFBQVEsQ0FBQ3pNLFFBQVE7b0NBQ2pEc0YsRUFBRSxJQUFJLENBQUMsRUFBRTlHLE1BQU0sRUFBRXlGLG9CQUFvQixDQUFDd0ksUUFBUTtvQ0FDOUNsTCxHQUFHLEdBQUc3RCxXQUFXLEVBQUUsQ0FBQyxFQUFFWSxvQkFBb0IsRUFBRWtDLG1CQUFtQixDQUFDL0MsV0FBVyxDQUFDOEQsR0FBRyxJQUFJNUQsV0FBVyxDQUFDNEQsR0FBRyxJQUFJQSxHQUFHLEVBQUUsSUFBSSxDQUFDakIsT0FBTyxFQUFFTixRQUFRO2dDQUNySSxDQUFDO2dDQUNHMk0sV0FBVyxHQUFHLEtBQUs7Z0NBQ3ZCLEVBQXdFO2dDQUN4RSxFQUEwQztnQ0FDMUMsRUFBRSxFQUFFeE4sS0FBK0IsRUFBRSxFQVVwQztnQ0FDS3VCLGNBQWMsR0FBR3hCLGtCQUFrQixDQUFDLElBQUksQ0FBQ3FCLGFBQWEsRUFBRUksU0FBUyxFQUFFLElBQUksQ0FBQ04sTUFBTTtnQ0FDcEYsRUFBd0U7Z0NBQ3hFLEVBQTBDO2dDQUMxQyxFQUFFLEVBQUVsQixLQUErQixFQUFFLEVBVXBDO3FDQUNHd04sV0FBVzs7Ozs2REFDSixHQUFHLENBQUMwQixPQUFPLENBQUMsUUFDakMsR0FEcUMsQ0FBQztnQ0FDeEIsQ0FBQzs7Z0NBR1QsRUFBRSxHQUFHNUUsT0FBTyxDQUFDMkUsRUFBRSxFQUFFLENBQUM7b0NBQ2QsSUFBSSxDQUFDL0QsS0FBSyxHQUFHLEtBQUs7Z0NBQ3RCLENBQUM7Z0NBQ0QsRUFBb0Q7Z0NBQ3BELEVBQUUsRUFBRTdMLE1BQU0sQ0FBQzhQLEVBQUUsRUFBRSxDQUFDO29DQUNaQyxXQUFXLENBQUNDLElBQUksQ0FBQyxDQUFhO2dDQUNsQyxDQUFDOzt1Q0FDMkIvRSxPQUFPLGNBQTNCZSxPQUFPLEVBQVBBLE9BQU8scUJBQUUsS0FBSztnQ0FDaEJzQyxVQUFVLEdBQUcsQ0FBQztvQ0FDaEJ0QyxPQUFPLEVBQVBBLE9BQU87Z0NBQ1gsQ0FBQztnQ0FDRCxFQUFFLEVBQUUsSUFBSSxDQUFDaUUsY0FBYyxFQUFFLENBQUM7b0NBQ3RCLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDRCxjQUFjLEVBQUUzQixVQUFVO2dDQUMzRCxDQUFDO2dDQUNEeEgsRUFBRSxHQUFHNUgsV0FBVyxDQUFDSCxTQUFTLENBQUNFLFdBQVcsQ0FBQzZILEVBQUUsSUFBSTNILFdBQVcsQ0FBQzJILEVBQUUsSUFBSUEsRUFBRSxFQUFFbUUsT0FBTyxDQUFDcEosTUFBTSxFQUFFLElBQUksQ0FBQ1MsYUFBYTtnQ0FDL0ZpTSxTQUFTLEdBQUd2UCxTQUFTLENBQUNDLFdBQVcsQ0FBQzZILEVBQUUsSUFBSTNILFdBQVcsQ0FBQzJILEVBQUUsSUFBSUEsRUFBRSxFQUFFLElBQUksQ0FBQ2pGLE1BQU07Z0NBQy9FLElBQUksQ0FBQ29PLGNBQWMsR0FBR25KLEVBQUU7Z0NBQ3BCMEgsWUFBWSxHQUFHUixVQUFVLEtBQUssSUFBSSxDQUFDbk0sTUFBTTt1Q0FNeENvSixPQUFPLENBQUMyRSxFQUFFLElBQUksSUFBSSxDQUFDTyxlQUFlLENBQUM1QixTQUFTLE1BQU1DLFlBQVk7Ozs7Z0NBQy9ELElBQUksQ0FBQ3JJLE1BQU0sR0FBR29JLFNBQVM7Z0NBQ3ZCMUUsTUFBTSxDQUFDMkMsTUFBTSxDQUFDNEQsSUFBSSxDQUFDLENBQWlCLGtCQUFFdEosRUFBRSxFQUFFd0gsVUFBVTtnQ0FDcEQsRUFBOEQ7Z0NBQzlELElBQUksQ0FBQ3pELFdBQVcsQ0FBQ2lELE1BQU0sRUFBRS9LLEdBQUcsRUFBRStELEVBQUUsRUFBRW1FLE9BQU87Z0NBQ3pDLElBQUksQ0FBQ29GLFlBQVksQ0FBQzlCLFNBQVM7Z0NBQzNCLElBQUksQ0FBQytCLE1BQU0sQ0FBQyxJQUFJLENBQUNwRSxVQUFVLENBQUMsSUFBSSxDQUFDNUksS0FBSyxHQUFHLElBQUk7Z0NBQzdDdUcsTUFBTSxDQUFDMkMsTUFBTSxDQUFDNEQsSUFBSSxDQUFDLENBQW9CLHFCQUFFdEosRUFBRSxFQUFFd0gsVUFBVTs2REFDaEQsSUFBSTs7Z0NBRVhHLE1BQU0sSUFBSSxDQUFDLEVBQUV2TyxpQkFBaUIsRUFBRTBMLGdCQUFnQixDQUFDN0ksR0FBRzs7dUNBQzVCMEwsTUFBTSxFQUE1QmpOLFFBQVEsUUFBUkEsUUFBUSxFQUFHZ0MsS0FBSyxRQUFMQSxLQUFLOzs7O3VDQU15QnFNLE9BQU8sQ0FBQ1UsR0FBRyxDQUFDLENBQUM7b0NBQ3BELElBQUksQ0FBQ3hHLFVBQVUsQ0FBQ3lHLFdBQVc7cUNBQzFCLENBQUMsRUFBRTlRLFlBQVksRUFBRStRLHNCQUFzQjtvQ0FDeEMsSUFBSSxDQUFDMUcsVUFBVSxDQUFDMkcsaUJBQWlCO2dDQUNyQyxDQUFDOzs7a0RBSkFySixLQUFLLDRCQUFnQnFILFFBQVEsUUFBcEJpQyxVQUFVOzs7Ozs7Z0NBTXBCLEVBQXdFO2dDQUN4RSxFQUErQjtnQ0FDL0I1SSxNQUFNLENBQUN5QixRQUFRLENBQUNuRSxJQUFJLEdBQUd5QixFQUFFOzZEQUNsQixLQUFLOztnQ0FFaEIsRUFBdUU7Z0NBQ3ZFLEVBQThFO2dDQUM5RSxFQUF1RDtnQ0FDdkQsRUFBb0U7Z0NBQ3BFLEVBQXNFO2dDQUN0RSxFQUFFLEdBQUcsSUFBSSxDQUFDOEosUUFBUSxDQUFDckMsU0FBUyxNQUFNQyxZQUFZLEVBQUUsQ0FBQztvQ0FDN0NWLE1BQU0sR0FBRyxDQUFjO2dDQUMzQixDQUFDO2dDQUdHL0csVUFBVSxHQUFHRCxFQUFFO2dDQUNuQixFQUE2RDtnQ0FDN0QsRUFBZ0U7Z0NBQ2hFLEVBQTJEO2dDQUMzRHRGLFFBQVEsR0FBR0EsUUFBUSxJQUFJLENBQUMsRUFBRWhDLHVCQUF1QixFQUFFK0gsdUJBQXVCLENBQUNwSSxXQUFXLENBQUNxQyxRQUFRLEtBQUtBLFFBQVE7Z0NBQzVHLEVBQUUsRUFBRXVNLGlCQUFpQixJQUFJdk0sUUFBUSxLQUFLLENBQVMsVUFBRSxDQUFDO29DQUM5Q3lKLE9BQU8sQ0FBQ3VDLGtCQUFrQixHQUFHLElBQUk7b0NBQ2pDLEVBQUUsRUFBRTdNLEtBQW9ELEVBQUcsRUFXMUQsTUFBTSxDQUFDO3dDQUNKOE4sTUFBTSxDQUFDak4sUUFBUSxHQUFHNEYsbUJBQW1CLENBQUM1RixRQUFRLEVBQUU2RixLQUFLO3dDQUNyRCxFQUFFLEVBQUVvSCxNQUFNLENBQUNqTixRQUFRLEtBQUtBLFFBQVEsRUFBRSxDQUFDOzRDQUMvQkEsUUFBUSxHQUFHaU4sTUFBTSxDQUFDak4sUUFBUTs0Q0FDMUJpTixNQUFNLENBQUNqTixRQUFRLEdBQUd0QyxXQUFXLENBQUNzQyxRQUFROzRDQUN0Q3VCLEdBQUcsSUFBSSxDQUFDLEVBQUUvQyxNQUFNLEVBQUV5RixvQkFBb0IsQ0FBQ2dKLE1BQU07d0NBQ2pELENBQUM7b0NBQ0wsQ0FBQztnQ0FDTCxDQUFDO29DQUNJclAsVUFBVSxDQUFDMEgsRUFBRTs7Ozt5Q0FDMkIsRUFBRTtnQ0FDdkMsS0FBSyxDQUFDLEdBQUcsQ0FBQzVGLEtBQUssQ0FBRSxDQUFlLGtCQUFtQjRGLE1BQUUsQ0FBbkIvRCxHQUFHLEVBQUMsQ0FBVyxnQkFBSyxNQUF5QyxDQUE1QytELEVBQUUsRUFBQyxDQUF5QywrQ0FBSyxDQUFrRjs7Z0NBRTFMaUIsTUFBTSxDQUFDeUIsUUFBUSxDQUFDbkUsSUFBSSxHQUFHeUIsRUFBRTs2REFDbEIsS0FBSzs7Z0NBRWhCQyxVQUFVLEdBQUcvSCxTQUFTLENBQUNHLFdBQVcsQ0FBQzRILFVBQVUsR0FBRyxJQUFJLENBQUNsRixNQUFNOzt1Q0FDdEMsSUFBSSxDQUFDa1AsaUJBQWlCLENBQUMsQ0FBQztvQ0FDekNqSyxFQUFFLEVBQUZBLEVBQUU7b0NBQ0ZrSyxLQUFLLEVBOXBCakIsQ0FBYSxpQkE4cEIrQixDQUFZO29DQUM1QzNKLEtBQUssRUFBTEEsS0FBSztvQ0FDTDdGLFFBQVEsRUFBUkEsUUFBUTtvQ0FDUmdDLEtBQUssRUFBTEEsS0FBSztnQ0FDVCxDQUFDOztnQ0FOS29MLE1BQU07c0NBT1JBLE1BQU0sQ0FBQ3FDLElBQUksS0FBSyxDQUFTOzs7O2dDQUFFLENBQUM7b0NBQzVCek4sS0FBSzt1Q0FDRUEsS0FBSyxFQUNMb0wsTUFBTSxDQUFDWCxRQUFRLENBQUN6SyxLQUFLO29DQUU1QnVELFVBQVUsR0FBRzZILE1BQU0sQ0FBQ3pJLE1BQU07b0NBQzFCM0UsUUFBUSxHQUFHb04sTUFBTSxDQUFDbEksWUFBWTtvQ0FDOUIrSCxNQUFNLENBQUNqTixRQUFRLEdBQUdvTixNQUFNLENBQUNsSSxZQUFZO29DQUNyQzNELEdBQUcsSUFBSSxDQUFDLEVBQUUvQyxNQUFNLEVBQUV5RixvQkFBb0IsQ0FBQ2dKLE1BQU07Z0NBQ2pELENBQUM7Ozs7c0NBQVVHLE1BQU0sQ0FBQ3FDLElBQUksS0FBSyxDQUFVLGFBQUlyQyxNQUFNLENBQUNVLEtBQUs7Ozs7NkRBQzFDLElBQUksQ0FBQ3ZELE1BQU0sQ0FBQytCLE1BQU0sRUFBRWMsTUFBTSxDQUFDUyxNQUFNLEVBQUVULE1BQU0sQ0FBQ1UsS0FBSyxFQUFFckUsT0FBTzs7c0NBQ3hEMkQsTUFBTSxDQUFDcUMsSUFBSSxLQUFLLENBQVUsYUFBSXJDLE1BQU0sQ0FBQ08sV0FBVzs7OztnQ0FDdkRwSCxNQUFNLENBQUN5QixRQUFRLENBQUNuRSxJQUFJLEdBQUd1SixNQUFNLENBQUNPLFdBQVc7NkRBQ2xDLEdBQUcsQ0FBQ1UsT0FBTyxDQUFDLFFBQzdCLEdBRGlDLENBQUM7Z0NBQ3hCLENBQUM7O3NDQUNNakIsTUFBTSxDQUFDcUMsSUFBSSxLQUFLLENBQVM7Ozs7Z0NBQ2hDbEosTUFBTSxDQUFDeUIsUUFBUSxDQUFDbkUsSUFBSSxHQUFHeUIsRUFBRTs2REFDbEIsR0FBRyxDQUFDK0ksT0FBTyxDQUFDLFFBQzdCLEdBRGlDLENBQUM7Z0NBQ3hCLENBQUM7O2dDQUVDdk0sS0FBSyxJQUFJLENBQUMsRUFBRTlELHVCQUF1QixFQUFFK0gsdUJBQXVCLENBQUMvRixRQUFRO3NDQUN0RSxDQUFDLEVBQUV2QixVQUFVLEVBQUVxRyxjQUFjLENBQUNoRCxLQUFLOzs7O2dDQUM5QjJLLFNBQVEsSUFBSSxDQUFDLEVBQUUvTixpQkFBaUIsRUFBRTBMLGdCQUFnQixDQUFDN0UsVUFBVTtnQ0FDN0R4RCxVQUFVLEdBQUcwSyxTQUFRLENBQUN6TSxRQUFRO2dDQUM5QnFOLFVBQVUsSUFBSSxDQUFDLEVBQUV2TyxXQUFXLEVBQUVxRCxhQUFhLENBQUNMLEtBQUs7Z0NBQ2pEd0wsVUFBVSxJQUFJLENBQUMsRUFBRXpPLGFBQWEsRUFBRTBELGVBQWUsQ0FBQzhLLFVBQVUsRUFBRXRMLFVBQVU7Z0NBQ3RFd0wsaUJBQWlCLEdBQUd6TCxLQUFLLEtBQUtDLFVBQVU7Z0NBQ3hDOEMsY0FBYyxHQUFHMEksaUJBQWlCLEdBQUcxUCxhQUFhLENBQUNpRSxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxJQUFJLENBQUM7Z0NBQ3RGLENBQUM7dUNBQ0lzTCxVQUFVLElBQUlDLGlCQUFpQixLQUFLMUksY0FBYyxDQUFDdkIsTUFBTTs7OztnQ0FDcERrSyxhQUFhLEdBQUd0USxNQUFNLENBQUN1RixJQUFJLENBQUM0SyxVQUFVLENBQUNoTCxNQUFNLEVBQUVxTixNQUFNLENBQUMsUUFBUSxDQUFQL00sS0FBSztvQ0FBRyxNQUFNLEVBQUxYLEtBQUssQ0FBQ1csS0FBSzs7c0NBRTdFNkssYUFBYSxDQUFDcE4sTUFBTSxHQUFHLENBQUM7Ozs7Z0NBQ3hCLEVBQUUsRUFwc0J0QixJQW9zQjZELEVBQUUsQ0FBQztvQ0FDeENtRSxPQUFPLENBQUNvTCxJQUFJLENBQUUsR0FBK0UsTUFBNEIsQ0FBekdwQyxpQkFBaUIsR0FBSSxDQUFrQixzQkFBSyxDQUErQiw4QkFBRSxDQUE0QixpQ0FBSyxDQUFZLGNBQTJCLE1BQTRCLENBQXJEQyxhQUFhLENBQUNuSyxJQUFJLENBQUMsQ0FBSSxNQUFFLENBQTRCO2dDQUNyTSxDQUFDO2dDQUNELEtBQUssQ0FBQyxHQUFHLENBQUMzRCxLQUFLLEVBQUU2TixpQkFBaUIsR0FBSSxDQUF1Qix1QkFBeUNDLE1BQXdCLENBQS9Eak0sR0FBRyxFQUFDLENBQWlDLG9DQUEyQixNQUErQixDQUF4RGlNLGFBQWEsQ0FBQ25LLElBQUksQ0FBQyxDQUFJLE1BQUUsQ0FBK0Isb0NBQUssQ0FBMkIsMkJBQTBEdkIsTUFBSyxDQUE3REMsVUFBVSxFQUFDLENBQTJDLDRDQUFRLE1BQUcsQ0FBVEQsS0FBSyxFQUFDLENBQUcsU0FBTSxDQUE0Qyw4Q0FBMkUsT0FBekV5TCxpQkFBaUIsR0FBRyxDQUEyQiw2QkFBRyxDQUFzQjs7Ozs7Z0NBRTlYLEVBQUUsRUFBRUEsaUJBQWlCLEVBQUUsQ0FBQztvQ0FDM0JqSSxFQUFFLElBQUksQ0FBQyxFQUFFOUcsTUFBTSxFQUFFeUYsb0JBQW9CLENBQUMvRyxNQUFNLENBQUN1QyxNQUFNLENBQUMsQ0FBQztvQ0FDckQsQ0FBQyxFQUFFZ04sU0FBUSxFQUFFLENBQUM7d0NBQ1Z6TSxRQUFRLEVBQUU2RSxjQUFjLENBQUN2QixNQUFNO3dDQUMvQnRCLEtBQUssRUFBRXVCLGtCQUFrQixDQUFDdkIsS0FBSyxFQUFFNkMsY0FBYyxDQUFDckMsTUFBTTtvQ0FDMUQsQ0FBQztnQ0FDTCxDQUFDLE1BQU0sQ0FBQztvQ0FDSixFQUFpRTtvQ0FDakV0RixNQUFNLENBQUN1QyxNQUFNLENBQUN1QyxLQUFLLEVBQUVzTCxVQUFVO2dDQUNuQyxDQUFDOztnQ0FFTGpGLE1BQU0sQ0FBQzJDLE1BQU0sQ0FBQzRELElBQUksQ0FBQyxDQUFrQixtQkFBRXRKLEVBQUUsRUFBRXdILFVBQVU7Ozs7dUNBRzNCLElBQUksQ0FBQzhDLFlBQVksQ0FBQzlOLEtBQUssRUFBRTlCLFFBQVEsRUFBRWdDLEtBQUssRUFBRXNELEVBQUUsRUFBRUMsVUFBVSxFQUFFdUgsVUFBVTs7Z0NBQXRGWSxTQUFTOzt1Q0FDZ0NBLFNBQVMsRUFBaERsSixLQUFLLFFBQUxBLEtBQUssRUFBR29HLEtBQUssUUFBTEEsS0FBSyxFQUFHQyxPQUFPLFFBQVBBLE9BQU8sRUFBR0MsT0FBTyxRQUFQQSxPQUFPO3VDQUVsQ0QsT0FBTyxJQUFJQyxPQUFPLEtBQUtGLEtBQUs7Ozs7c0NBQ3pCQSxLQUFLLENBQUNpRixTQUFTLElBQUlqRixLQUFLLENBQUNpRixTQUFTLENBQUNDLFlBQVk7Ozs7Z0NBQ3pDbkMsV0FBVyxHQUFHL0MsS0FBSyxDQUFDaUYsU0FBUyxDQUFDQyxZQUFZO3NDQUk1Q25DLFdBQVcsQ0FBQzVOLFVBQVUsQ0FBQyxDQUFHLE9BQUs2SyxLQUFLLENBQUNpRixTQUFTLENBQUNFLHNCQUFzQixLQUFLLEtBQUs7Ozs7Z0NBQ3pFbkMsVUFBVSxJQUFJLENBQUMsRUFBRWxQLGlCQUFpQixFQUFFMEwsZ0JBQWdCLENBQUN1RCxXQUFXO2dDQUN0RUMsVUFBVSxDQUFDNU4sUUFBUSxHQUFHNEYsbUJBQW1CLENBQUNnSSxVQUFVLENBQUM1TixRQUFRLEVBQUU2RixLQUFLOzt1Q0FDL0JSLFlBQVksQ0FBQyxJQUFJLEVBQUVzSSxXQUFXLEVBQUVBLFdBQVcsR0FBbkVFLE1BQU0sUUFBWHRNLEdBQUcsRUFBZXVNLEtBQUssUUFBVHhJLEVBQUU7NkRBQ2pCLElBQUksQ0FBQ2lGLE1BQU0sQ0FBQytCLE1BQU0sRUFBRXVCLE1BQU0sRUFBRUMsS0FBSyxFQUFFckUsT0FBTzs7Z0NBRXJEbEQsTUFBTSxDQUFDeUIsUUFBUSxDQUFDbkUsSUFBSSxHQUFHOEosV0FBVzs2REFDM0IsR0FBRyxDQUFDVSxPQUFPLENBQUMsUUFDckMsR0FEeUMsQ0FBQztnQ0FDeEIsQ0FBQzs7Z0NBRUwsSUFBSSxDQUFDeEYsU0FBUyxLQUFLK0IsS0FBSyxDQUFDb0YsV0FBVztzQ0FFaENwRixLQUFLLENBQUNsRCxRQUFRLEtBQUtaLGtCQUFrQjs7Ozs7Ozt1Q0FHM0IsSUFBSSxDQUFDbUosY0FBYyxDQUFDLENBQU07O2dDQUNoQ2xDLGFBQWEsR0FBRyxDQUFNOzs7Ozs7Z0NBRXRCQSxhQUFhLEdBQUcsQ0FBUzs7O3VDQUVYLElBQUksQ0FBQzZCLFlBQVksQ0FBQzdCLGFBQWEsRUFBRUEsYUFBYSxFQUFFL0wsS0FBSyxFQUFFc0QsRUFBRSxFQUFFQyxVQUFVLEVBQUUsQ0FBQztvQ0FDdEZpRixPQUFPLEVBQUUsS0FBSztnQ0FDbEIsQ0FBQzs7Z0NBRkRrRCxTQUFTOztnQ0FLakJyRixNQUFNLENBQUMyQyxNQUFNLENBQUM0RCxJQUFJLENBQUMsQ0FBcUIsc0JBQUV0SixFQUFFLEVBQUV3SCxVQUFVO2dDQUN4RCxJQUFJLENBQUN6RCxXQUFXLENBQUNpRCxNQUFNLEVBQUUvSyxHQUFHLEVBQUUrRCxFQUFFLEVBQUVtRSxPQUFPO2dDQUN6QyxFQUFFLEVBQUVBLE9BQU8sQ0FBQzJFLEVBQUUsSUFBSXBPLFFBQVEsS0FBSyxDQUFTLGNBQU00TSxHQUFHLEdBQUc5QyxJQUFJLENBQUNvQixhQUFhLENBQUNOLEtBQUssTUFBTSxJQUFJLElBQUlnQyxHQUFHLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJYSxJQUFJLEdBQUdiLEdBQUcsQ0FBQ2lELFNBQVMsTUFBTSxJQUFJLElBQUlwQyxJQUFJLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHQSxJQUFJLENBQUN5QyxVQUFVLE1BQU0sR0FBRyxLQUFLdEYsS0FBSyxLQUFLLElBQUksSUFBSUEsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBR0EsS0FBSyxDQUFDaUYsU0FBUyxHQUFHLENBQUM7b0NBQzVRLEVBQXlEO29DQUN6RCxFQUFrQztvQ0FDbENqRixLQUFLLENBQUNpRixTQUFTLENBQUNLLFVBQVUsR0FBRyxHQUFHO2dDQUNwQyxDQUFDO2dDQUVLbEMsbUJBQW1CLEdBQUd2RSxPQUFPLENBQUNlLE9BQU8sSUFBSSxJQUFJLENBQUMxSSxLQUFLLEtBQUtBLEtBQUs7O2dDQUU3RG9NLFlBQVksSUFBSUQsT0FBTyxHQUFHeEUsT0FBTyxDQUFDMEcsTUFBTSxNQUFNLElBQUksSUFBSWxDLE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHQSxPQUFPLElBQUlELG1CQUFtQjtnQ0FDekdHLFdBQVcsR0FBR0QsWUFBWSxHQUFHLENBQUM7b0NBQ2hDckUsQ0FBQyxFQUFFLENBQUM7b0NBQ0pHLENBQUMsRUFBRSxDQUFDO2dDQUNSLENBQUMsR0FBRyxJQUFJOzt1Q0FDRixJQUFJLENBQUNvRyxHQUFHLENBQUN0TyxLQUFLLEVBQUU5QixRQUFRLEVBQUVnQyxLQUFLLEVBQUUrSyxTQUFTLEVBQUVXLFNBQVMsRUFBRWxFLFlBQVksS0FBSyxJQUFJLElBQUlBLFlBQVksS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHQSxZQUFZLEdBQUcyRSxXQUFXLEVBQUVqRyxLQUFLLENBQUMsUUFDN0osQ0FEOEppQixDQUFDLEVBQUcsQ0FBQztvQ0FDcEosRUFBRSxFQUFFQSxDQUFDLENBQUN4SixTQUFTLEVBQUU2RSxLQUFLLEdBQUdBLEtBQUssSUFBSTJFLENBQUM7eUNBQzlCLEtBQUssQ0FBQ0EsQ0FBQztnQ0FDaEIsQ0FBQzs7cUNBQ0czRSxLQUFLOzs7O2dDQUNMNkQsTUFBTSxDQUFDMkMsTUFBTSxDQUFDNEQsSUFBSSxDQUFDLENBQWtCLG1CQUFFcEssS0FBSyxFQUFFdUksU0FBUyxFQUFFRCxVQUFVO2dDQUNuRSxLQUFLLENBQUN0SSxLQUFLOztnQ0FFZixFQUFFLEVBQUVyRixLQUErQixFQUFFLEVBSXBDO2dDQUNEa0osTUFBTSxDQUFDMkMsTUFBTSxDQUFDNEQsSUFBSSxDQUFDLENBQXFCLHNCQUFFdEosRUFBRSxFQUFFd0gsVUFBVTs2REFDakQsSUFBSTs7Ozt1Q0FFTixDQUFDLEVBQUUzTyxRQUFRLEVBQUVKLE9BQU8scUJBQWU0QixTQUFTOzs7OzZEQUN0QyxLQUFLOztnQ0FFaEIsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFFYixDQUFDOzs7O1lBQ0QwSixHQUFXLEVBQVhBLENBQVc7bUJBQVhBLFFBQVEsQ0FBUkEsV0FBVyxDQUFDaUQsTUFBTSxFQUFFL0ssR0FBRyxFQUFFK0QsRUFBRSxFQUFFbUUsS0FDNUIsRUFBRSxDQUFDO29CQUR5QkEsT0FBTyxHQUFQQSxLQUM1QixjQURzQyxDQUFDO2dCQUN4QyxDQUFDLEdBRDRCQSxLQUM1QjtnQkFDRyxFQUFFLEVBaHlCVixJQWd5QmlELEVBQUUsQ0FBQztvQkFDeEMsRUFBRSxFQUFFLE1BQU0sQ0FBQ2xELE1BQU0sQ0FBQ0MsT0FBTyxLQUFLLENBQVcsWUFBRSxDQUFDO3dCQUN4Q2pDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFFLENBQXlDO3dCQUN4RCxNQUFNO29CQUNWLENBQUM7b0JBQ0QsRUFBRSxFQUFFLE1BQU0sQ0FBQytCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDOEYsTUFBTSxNQUFNLENBQVcsWUFBRSxDQUFDO3dCQUNoRC9ILE9BQU8sQ0FBQ0MsS0FBSyxDQUFFLENBQXdCLDBCQUFTLE1BQWlCLENBQXhCOEgsTUFBTSxFQUFDLENBQWlCO3dCQUNqRSxNQUFNO29CQUNWLENBQUM7Z0JBQ0wsQ0FBQztnQkFDRCxFQUFFLEVBQUVBLE1BQU0sS0FBSyxDQUFXLGVBQUssQ0FBQyxFQUFFOU4sTUFBTSxFQUFFOEssTUFBTSxPQUFPaEUsRUFBRSxFQUFFLENBQUM7b0JBQ3hELElBQUksQ0FBQ21GLFFBQVEsR0FBR2hCLE9BQU8sQ0FBQ2UsT0FBTztvQkFDL0JqRSxNQUFNLENBQUNDLE9BQU8sQ0FBQzhGLE1BQU0sRUFBRSxDQUFDO3dCQUNwQi9LLEdBQUcsRUFBSEEsR0FBRzt3QkFDSCtELEVBQUUsRUFBRkEsRUFBRTt3QkFDRm1FLE9BQU8sRUFBUEEsT0FBTzt3QkFDUEYsR0FBRyxFQUFFLElBQUk7d0JBQ1RHLEdBQUcsRUFBRSxJQUFJLENBQUNULElBQUksR0FBR3FELE1BQU0sS0FBSyxDQUFXLGFBQUcsSUFBSSxDQUFDckQsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxHQUFHLENBQUM7b0JBQ3ZFLENBQUMsRUFDRCxFQUFxRjtvQkFDckYsRUFBd0U7b0JBQ3hFLENBQUUsR0FBRTNELEVBQUU7Z0JBQ1YsQ0FBQztZQUNMLENBQUM7OztZQUNLa0wsR0FBb0IsRUFBcEJBLENBQW9CO21CQUExQixRQUFRLENBQUZBLG9CQUFvQixDQUFDckksR0FBRyxFQUFFbkksUUFBUSxFQUFFZ0MsS0FBSyxFQUFFc0QsRUFBRSxFQUFFd0gsVUFBVSxFQUFFMkQsYUFBYTswRUFBOUUsUUFBUSxXQUF3RSxDQUFDO3dCQWtCckUvSCxTQUFTLEVBQ1RxQyxXQUFXLEVBQ1hILEtBQUssRUFJSDhDLFNBQVM7Ozs7cUNBdkJmdkYsR0FBRyxDQUFDeEksU0FBUzs7OztnQ0FDYixFQUFnQztnQ0FDaEMsS0FBSyxDQUFDd0ksR0FBRzs7dUNBRVIsQ0FBQyxFQUFFakssWUFBWSxFQUFFd1MsWUFBWSxDQUFDdkksR0FBRyxLQUFLc0ksYUFBYTs7OztnQ0FDcERwSSxNQUFNLENBQUMyQyxNQUFNLENBQUM0RCxJQUFJLENBQUMsQ0FBa0IsbUJBQUV6RyxHQUFHLEVBQUU3QyxFQUFFLEVBQUV3SCxVQUFVO2dDQUMxRCxFQUFpRTtnQ0FDakUsRUFBMEI7Z0NBQzFCLEVBQTBDO2dDQUMxQyxFQUE0QztnQ0FDNUMsRUFBK0Q7Z0NBQy9EdkcsTUFBTSxDQUFDeUIsUUFBUSxDQUFDbkUsSUFBSSxHQUFHeUIsRUFBRTtnQ0FDekIsRUFBa0U7Z0NBQ2xFLEVBQThEO2dDQUM5RCxLQUFLLENBQUM5RixzQkFBc0I7Ozs7OztzQ0FNeEIsTUFBTSxDQUFDa0osU0FBUyxLQUFLLENBQVcsY0FBSSxNQUFNLENBQUNxQyxXQUFXLEtBQUssQ0FBVzs7Ozs7dUNBQzFCLElBQUksQ0FBQ2tGLGNBQWMsQ0FBQyxDQUFTOzs7aURBQWhFdkgsU0FBUyxPQUFmeEMsSUFBSSxFQUFjNkUsV0FBVyxPQUFYQSxXQUFXOztnQ0FFOUIyQyxTQUFTLEdBQUcsQ0FBQztvQ0FDZjlDLEtBQUssRUFBTEEsS0FBSztvQ0FDTGxDLFNBQVMsRUFBVEEsU0FBUztvQ0FDVHFDLFdBQVcsRUFBWEEsV0FBVztvQ0FDWDVDLEdBQUcsRUFBSEEsR0FBRztvQ0FDSDNELEtBQUssRUFBRTJELEdBQUc7Z0NBQ2QsQ0FBQztvQ0FDSXVGLFNBQVMsQ0FBQzlDLEtBQUs7Ozs7Ozt1Q0FFWSxJQUFJLENBQUMrRixlQUFlLENBQUNqSSxTQUFTLEVBQUUsQ0FBQztvQ0FDckRQLEdBQUcsRUFBSEEsR0FBRztvQ0FDSG5JLFFBQVEsRUFBUkEsUUFBUTtvQ0FDUmdDLEtBQUssRUFBTEEsS0FBSztnQ0FDVCxDQUFDOztnQ0FKRDBMLFNBQVMsQ0FBQzlDLEtBQUs7Ozs7OztnQ0FNZnJHLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLENBQXlDO2dDQUN2RGtKLFNBQVMsQ0FBQzlDLEtBQUssR0FBRyxDQUFDO2dDQUNuQixDQUFDOzs2REFHRjhDLFNBQVM7Ozs7NkRBRVQsSUFBSSxDQUFDOEMsb0JBQW9CLEVBQUUsQ0FBQyxFQUFFclMsUUFBUSxFQUFFSixPQUFPLHNCQUFnQyxHQUFHLENBQUMyQixLQUFLLFdBQWdCLENBQUUsSUFBR00sUUFBUSxFQUFFZ0MsS0FBSyxFQUFFc0QsRUFBRSxFQUFFd0gsVUFBVSxFQUFFLElBQUk7Ozs7Ozs7Ozs7Ozs7OztnQkFFakssQ0FBQzs7OztZQUNLOEMsR0FBWSxFQUFaQSxDQUFZO21CQUFsQixRQUFRLENBQUZBLFlBQVksQ0FBQzlOLEtBQUssRUFBRTlCLFFBQVEsRUFBRWdDLEtBQUssRUFBRXNELEVBQUUsRUFBRUMsVUFBVSxFQUFFdUgsVUFBVTswRUFBckUsUUFBUSxXQUErRCxDQUFDOytCQUUxRDhELGlCQUFpQixFQUluQkMsZUFBZSxFQU1ibkQsU0FBUyxFQU9QaEYsU0FBUyxFQUFHbUMsT0FBTyxFQUFHQyxPQUFPLEVBRXpCZ0csa0JBQWtCLEVBSzFCbEosUUFBUSxFQU9OZ0QsS0FBSzs7Ozs7O2dDQS9CTGdHLGlCQUFpQixHQUFHLElBQUksQ0FBQ2xHLFVBQVUsQ0FBQzVJLEtBQUs7c0NBQzNDZ0wsVUFBVSxDQUFDdEMsT0FBTyxJQUFJb0csaUJBQWlCLElBQUksSUFBSSxDQUFDOU8sS0FBSyxLQUFLQSxLQUFLOzs7OzZEQUN4RDhPLGlCQUFpQjs7Z0NBRXhCQyxlQUFlLEdBQUdsUSxTQUFTO2dDQUMvQixFQUFzQztnQ0FDdEMsRUFBdUU7Z0NBQ3ZFLEVBQUUsRUFsM0JkLEtBazNCZ0gsRUFBRSxFQUVyRzswQ0FDaUJrUSxlQUFlOzs7Ozs7dUNBQVUsSUFBSSxDQUFDWixjQUFjLENBQUNuTyxLQUFLLEVBQUVzRixJQUFJLENBQUMsUUFBUSxDQUFQQyxHQUFHO29DQUFHLE1BQzNGLENBRDRGLENBQUM7d0NBQzVFcUIsU0FBUyxFQUFFckIsR0FBRyxDQUFDbkIsSUFBSTt3Q0FDbkI2RSxXQUFXLEVBQUUxRCxHQUFHLENBQUMwRCxXQUFXO3dDQUM1QkYsT0FBTyxFQUFFeEQsR0FBRyxDQUFDMEosR0FBRyxDQUFDbEcsT0FBTzt3Q0FDeEJDLE9BQU8sRUFBRXpELEdBQUcsQ0FBQzBKLEdBQUcsQ0FBQ2pHLE9BQU87b0NBQzVCLENBQUM7Ozs7O2dDQUxDNEMsU0FBUzs7c0NBTzRCQSxTQUFTLEVBQTVDaEYsU0FBUyxPQUFUQSxTQUFTLEVBQUdtQyxPQUFPLE9BQVBBLE9BQU8sRUFBR0MsT0FBTyxPQUFQQSxPQUFPO3lDQUNJLEVBQUU7Z0NBQy9CZ0csa0JBQWtCLEdBQU03UywwRkFBTjtvQ0FDckI2UyxrQkFBa0IsQ0FBQ3BJLFNBQVM7Ozs7Z0NBQzdCLEtBQUssQ0FBQyxHQUFHLENBQUNoSixLQUFLLENBQUUsQ0FBc0QseURBQVcsTUFBQyxDQUFWTSxRQUFRLEVBQUMsQ0FBQzs7O2dDQUkzRixFQUFFLEVBQUU2SyxPQUFPLElBQUlDLE9BQU8sRUFBRSxDQUFDO29DQUNyQmxELFFBQVEsR0FBRyxJQUFJLENBQUNXLFVBQVUsQ0FBQ3lJLFdBQVcsRUFBRSxDQUFDLEVBQUV4UyxNQUFNLEVBQUV5RixvQkFBb0IsQ0FBQyxDQUFDO3dDQUNyRWpFLFFBQVEsRUFBUkEsUUFBUTt3Q0FDUmdDLEtBQUssRUFBTEEsS0FBSztvQ0FDVCxDQUFDLEdBQUd1RCxVQUFVLEVBQUVzRixPQUFPLEVBQUUsSUFBSSxDQUFDeEssTUFBTTtnQ0FDeEMsQ0FBQzs7dUNBQ21CLElBQUksQ0FBQzRRLFFBQVEsQ0FBQyxRQUFRO29DQUFKcEcsTUFBTSxDQUFOQSxPQUFPLElBQUlDLE9BQU8sR0FBR25ELGFBQWEsQ0FBQ0MsUUFBUSxRQUFPeUMsS0FBSyxFQUFFUSxPQUFPLFNBQVEvQixHQUFHLFNBQVFDLEdBQUcsSUFBSThCLE9BQU8sVUFBUzhGLGVBQWUsQ0FBQ2pJLFNBQVMsRUFDckssQ0FBQzt3Q0FDRzFJLFFBQVEsRUFBUkEsUUFBUTt3Q0FDUmdDLEtBQUssRUFBTEEsS0FBSzt3Q0FDTDJDLE1BQU0sRUFBRVcsRUFBRTt3Q0FDVmpGLE1BQU0sUUFBT0EsTUFBTTt3Q0FDbkJDLE9BQU8sUUFBT0EsT0FBTzt3Q0FDckJRLGFBQWEsUUFBT0EsYUFBYTtvQ0FDckMsQ0FBQzs7O2dDQVJDOEosS0FBSztnQ0FVWDhDLFNBQVMsQ0FBQzlDLEtBQUssR0FBR0EsS0FBSztnQ0FDdkIsSUFBSSxDQUFDRixVQUFVLENBQUM1SSxLQUFLLElBQUk0TCxTQUFTOzZEQUMzQkEsU0FBUzs7Ozs2REFFVCxJQUFJLENBQUM4QyxvQkFBb0IsRUFBRSxDQUFDLEVBQUVyUyxRQUFRLEVBQUVKLE9BQU8sc0JBQWMsR0FBRyxDQUFDMkIsS0FBSyxXQUFPLENBQUUsSUFBR00sUUFBUSxFQUFFZ0MsS0FBSyxFQUFFc0QsRUFBRSxFQUFFd0gsVUFBVTs7Ozs7Ozs7Ozs7Z0JBRWhJLENBQUM7Ozs7WUFDRHNELEdBQUcsRUFBSEEsQ0FBRzttQkFBSEEsUUFBUSxDQUFSQSxHQUFHLENBQUN0TyxLQUFLLEVBQUU5QixRQUFRLEVBQUVnQyxLQUFLLEVBQUVzRCxFQUFFLEVBQUVtQyxJQUFJLEVBQUUwRyxXQUFXLEVBQUUsQ0FBQztnQkFDaEQsSUFBSSxDQUFDdkYsVUFBVSxHQUFHLEtBQUs7Z0JBQ3ZCLElBQUksQ0FBQzlHLEtBQUssR0FBR0EsS0FBSztnQkFDbEIsSUFBSSxDQUFDOUIsUUFBUSxHQUFHQSxRQUFRO2dCQUN4QixJQUFJLENBQUNnQyxLQUFLLEdBQUdBLEtBQUs7Z0JBQ2xCLElBQUksQ0FBQzJDLE1BQU0sR0FBR1csRUFBRTtnQkFDaEIsTUFBTSxDQUFDLElBQUksQ0FBQ3dKLE1BQU0sQ0FBQ3JILElBQUksRUFBRTBHLFdBQVc7WUFDeEMsQ0FBQzs7O1lBQ0QsRUFHQzs7O0dBQUEsR0FBQytDLEdBQWMsRUFBZEEsQ0FBYzttQkFBZEEsUUFBUSxDQUFSQSxjQUFjLENBQUNDLEVBQUUsRUFBRSxDQUFDO2dCQUNsQixJQUFJLENBQUM3RyxJQUFJLEdBQUc2RyxFQUFFO1lBQ2xCLENBQUM7OztZQUNEeEMsR0FBZSxFQUFmQSxDQUFlO21CQUFmQSxRQUFRLENBQVJBLGVBQWUsQ0FBQ3JKLEVBQUUsRUFBRSxDQUFDO2dCQUNqQixFQUFFLEdBQUcsSUFBSSxDQUFDWCxNQUFNLEVBQUUsTUFBTSxDQUFDLEtBQUs7Z0JBQzlCLEdBQUssQ0FBMkIsR0FBc0Isa0JBQXRCLElBQUksQ0FBQ0EsTUFBTSxDQUFDTCxLQUFLLENBQUMsQ0FBRyxTQUE5QzhNLFlBQVksR0FBYSxHQUFzQixLQUFqQ0MsT0FBTyxHQUFJLEdBQXNCO2dCQUN0RCxHQUFLLENBQTJCL0wsSUFBYSxrQkFBYkEsRUFBRSxDQUFDaEIsS0FBSyxDQUFDLENBQUcsU0FBckNnTixZQUFZLEdBQWFoTSxJQUFhLEtBQXhCaU0sT0FBTyxHQUFJak0sSUFBYTtnQkFDN0MsRUFBeUU7Z0JBQ3pFLEVBQUUsRUFBRWlNLE9BQU8sSUFBSUgsWUFBWSxLQUFLRSxZQUFZLElBQUlELE9BQU8sS0FBS0UsT0FBTyxFQUFFLENBQUM7b0JBQ2xFLE1BQU0sQ0FBQyxJQUFJO2dCQUNmLENBQUM7Z0JBQ0QsRUFBMEQ7Z0JBQzFELEVBQUUsRUFBRUgsWUFBWSxLQUFLRSxZQUFZLEVBQUUsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLEtBQUs7Z0JBQ2hCLENBQUM7Z0JBQ0QsRUFBeUQ7Z0JBQ3pELEVBQXVEO2dCQUN2RCxFQUEyRDtnQkFDM0QsRUFBbUM7Z0JBQ25DLE1BQU0sQ0FBQ0QsT0FBTyxLQUFLRSxPQUFPO1lBQzlCLENBQUM7OztZQUNEMUMsR0FBWSxFQUFaQSxDQUFZO21CQUFaQSxRQUFRLENBQVJBLFlBQVksQ0FBQ3ZKLEVBQUUsRUFBRSxDQUFDO2dCQUNkLEdBQUssQ0FBWUEsR0FBYSxrQkFBYkEsRUFBRSxDQUFDaEIsS0FBSyxDQUFDLENBQUcsU0FBcEJXLElBQUksR0FBSUssR0FBYTtnQkFDOUIsRUFBZ0U7Z0JBQ2hFLEVBQXFCO2dCQUNyQixFQUFFLEVBQUVMLElBQUksS0FBSyxDQUFFLEtBQUlBLElBQUksS0FBSyxDQUFLLE1BQUUsQ0FBQztvQkFDaENzQixNQUFNLENBQUNpTCxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQ3BCLE1BQU07Z0JBQ1YsQ0FBQztnQkFDRCxFQUErQztnQkFDL0MsR0FBSyxDQUFDQyxJQUFJLEdBQUdwQixRQUFRLENBQUNxQixjQUFjLENBQUN6TSxJQUFJO2dCQUN6QyxFQUFFLEVBQUV3TSxJQUFJLEVBQUUsQ0FBQztvQkFDUEEsSUFBSSxDQUFDRSxjQUFjO29CQUNuQixNQUFNO2dCQUNWLENBQUM7Z0JBQ0QsRUFBa0U7Z0JBQ2xFLEVBQXFCO2dCQUNyQixHQUFLLENBQUNDLE1BQU0sR0FBR3ZCLFFBQVEsQ0FBQ3dCLGlCQUFpQixDQUFDNU0sSUFBSSxFQUFFLENBQUM7Z0JBQ2pELEVBQUUsRUFBRTJNLE1BQU0sRUFBRSxDQUFDO29CQUNUQSxNQUFNLENBQUNELGNBQWM7Z0JBQ3pCLENBQUM7WUFDTCxDQUFDOzs7WUFDRHZDLEdBQVEsRUFBUkEsQ0FBUTttQkFBUkEsUUFBUSxDQUFSQSxRQUFRLENBQUN6SyxNQUFNLEVBQUUsQ0FBQztnQkFDZCxNQUFNLENBQUMsSUFBSSxDQUFDQSxNQUFNLEtBQUtBLE1BQU07WUFDakMsQ0FBQzs7O1lBTU9tTixHQUFRLEVBQVJBLENBQVE7bUJBTGhCLEVBS0M7Ozs7O0dBQUEsR0FBQyxRQUFRLENBQUZBLFFBQVEsQ0FBQ3ZRLEdBQUcsRUFBRW9ELEtBQVksRUFBRThFLE1BQ25DO29CQURxQjlFLE1BQU0sR0FBTkEsS0FBWSxjQUFIcEQsR0FBRyxHQUFab0QsS0FBWSxFQUFFOEUsT0FBTyxHQUFQQSxNQUNuQyxjQUQ2QyxDQUFDO2dCQUMvQyxDQUFDLEdBRG1DQSxNQUNuQzswRUFEQyxRQUFRLFdBQ1AsQ0FBQzsrQkFDSXdELE1BQU0sRUFDSmpOLFFBQVEsRUFBR2dDLEtBQUssRUFNVnlLLFFBQVEsRUFDTkMsZ0JBQWdCLEVBTXhCN0csS0FBSyxFQUNQTixVQUFVLEVBRU4ySCxRQUFRLEVBRU5DLGNBQWMsRUFzQmxCNEUsT0FBTyxFQWlCUGpRLEtBQUs7Ozs7O2dDQTFEUG1MLE1BQU0sSUFBSSxDQUFDLEVBQUV2TyxpQkFBaUIsRUFBRTBMLGdCQUFnQixDQUFDN0ksR0FBRzs7c0NBQzVCMEwsTUFBTSxFQUE1QmpOLFFBQVEsT0FBUkEsUUFBUSxFQUFHZ0MsS0FBSyxPQUFMQSxLQUFLO2dDQUN0QixFQUFFLEVBQUU3QyxLQUErQixFQUFFLEVBV3BDOzt1Q0FDbUIsSUFBSSxDQUFDb0osVUFBVSxDQUFDeUcsV0FBVzs7Z0NBQXpDbkosS0FBSztnQ0FDUE4sVUFBVSxHQUFHWixNQUFNO3dDQUNxQzs7Ozs7O3dDQUVwQixDQUFDLEVBQUV6RyxZQUFZLEVBQUUrUSxzQkFBc0I7OztrREFBNUQvQixRQUFRLFFBQXBCaUMsVUFBVTtnQ0FDUGhDLGNBQWMsSUFBSSxDQUFDLEVBQUV2TyxnQkFBZ0IsRUFBRWIsT0FBTyxDQUFDTCxXQUFXLENBQUNILFNBQVMsQ0FBQ29ILE1BQU0sRUFBRSxJQUFJLENBQUN0RSxNQUFNLElBQUl3RixLQUFLLEVBQUVxSCxRQUFRLEVBQUVELE1BQU0sQ0FBQ2pMLEtBQUssRUFBRSxRQUFRLENBQVBxTixDQUFDO29DQUFHekosTUFBTSxDQUFOQSxtQkFBbUIsQ0FBQ3lKLENBQUMsRUFBRXhKLEtBQUs7bUNBQ2hLLElBQUksQ0FBQ3ZGLE9BQU87Z0NBQ2RpRixVQUFVLEdBQUcvSCxTQUFTLENBQUNHLFdBQVcsQ0FBQ3dQLGNBQWMsQ0FBQ3hJLE1BQU0sR0FBRyxJQUFJLENBQUN0RSxNQUFNO2dDQUN0RSxFQUFFLEVBQUU4TSxjQUFjLENBQUNtQyxXQUFXLElBQUluQyxjQUFjLENBQUNqSSxZQUFZLEVBQUUsQ0FBQztvQ0FDNUQsRUFBZ0U7b0NBQ2hFLEVBQTRDO29DQUM1Q2xGLFFBQVEsR0FBR21OLGNBQWMsQ0FBQ2pJLFlBQVk7b0NBQ3RDK0gsTUFBTSxDQUFDak4sUUFBUSxHQUFHQSxRQUFRO29DQUMxQnVCLEdBQUcsSUFBSSxDQUFDLEVBQUUvQyxNQUFNLEVBQUV5RixvQkFBb0IsQ0FBQ2dKLE1BQU07Z0NBQ2pELENBQUM7Ozs7Z0NBQ0UsQ0FBQztvQ0FDSkEsTUFBTSxDQUFDak4sUUFBUSxHQUFHNEYsbUJBQW1CLENBQUNxSCxNQUFNLENBQUNqTixRQUFRLEVBQUU2RixLQUFLO29DQUM1RCxFQUFFLEVBQUVvSCxNQUFNLENBQUNqTixRQUFRLEtBQUtBLFFBQVEsRUFBRSxDQUFDO3dDQUMvQkEsUUFBUSxHQUFHaU4sTUFBTSxDQUFDak4sUUFBUTt3Q0FDMUJpTixNQUFNLENBQUNqTixRQUFRLEdBQUdBLFFBQVE7d0NBQzFCdUIsR0FBRyxJQUFJLENBQUMsRUFBRS9DLE1BQU0sRUFBRXlGLG9CQUFvQixDQUFDZ0osTUFBTTtvQ0FDakQsQ0FBQztnQ0FDTCxDQUFDOzt5Q0FFd0MsRUFBRTs7Ozt1Q0FHckIsSUFBSSxDQUFDc0MsaUJBQWlCLENBQUMsQ0FBQztvQ0FDMUNqSyxFQUFFLEVBQUVYLE1BQU07b0NBQ1Y2SyxLQUFLLEVBQUUsSUFBSTtvQ0FDWDNKLEtBQUssRUFBTEEsS0FBSztvQ0FDTDdGLFFBQVEsRUFBUkEsUUFBUTtvQ0FDUmdDLEtBQUssRUFBTEEsS0FBSztnQ0FDVCxDQUFDOztnQ0FOSytQLE9BQU87Z0NBT2IsRUFBRSxFQUFFQSxPQUFPLENBQUN0QyxJQUFJLEtBQUssQ0FBUyxVQUFFLENBQUM7b0NBQzdCeEMsTUFBTSxDQUFDak4sUUFBUSxHQUFHK1IsT0FBTyxDQUFDN00sWUFBWTtvQ0FDdENsRixRQUFRLEdBQUcrUixPQUFPLENBQUM3TSxZQUFZO29DQUMvQmxELEtBQUs7dUNBQ0VBLEtBQUssRUFDTCtQLE9BQU8sQ0FBQ3RGLFFBQVEsQ0FBQ3pLLEtBQUs7b0NBRTdCdUQsVUFBVSxHQUFHd00sT0FBTyxDQUFDcE4sTUFBTTtvQ0FDM0JwRCxHQUFHLElBQUksQ0FBQyxFQUFFL0MsTUFBTSxFQUFFeUYsb0JBQW9CLENBQUNnSixNQUFNO2dDQUNqRCxDQUFDO2dDQUNLbkwsS0FBSyxJQUFJLENBQUMsRUFBRTlELHVCQUF1QixFQUFFK0gsdUJBQXVCLENBQUMvRixRQUFROzt1Q0FDckVxTyxPQUFPLENBQUNVLEdBQUcsQ0FBQyxDQUFDO29DQUNmLElBQUksQ0FBQ3hHLFVBQVUsQ0FBQ3lKLE1BQU0sQ0FBQ2xRLEtBQUssRUFBRXNGLElBQUksQ0FBQyxRQUFRLENBQVA2SyxLQUFLLEVBQUcsQ0FBQzt3Q0FDekMsTUFBTSxDQUFDQSxLQUFLLEdBQUd0SyxhQUFhLE9BQU1ZLFVBQVUsQ0FBQ3lJLFdBQVcsQ0FBQ3pQLEdBQUcsRUFBRWdFLFVBQVUsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDa0UsT0FBTyxDQUFDcEosTUFBTSxLQUFLLENBQVcsYUFBR29KLE9BQU8sQ0FBQ3BKLE1BQU0sU0FBUUEsTUFBTSxHQUFHLEtBQUssUUFBT3lJLEdBQUcsRUFBRSxJQUFJLElBQUksS0FBSztvQ0FDekwsQ0FBQztvQ0FDRCxJQUFJLENBQUNQLFVBQVUsQ0FBQ2tCLE9BQU8sQ0FBQ3lJLFFBQVEsR0FBRyxDQUFVLFlBQUcsQ0FBVSxXQUFFcFEsS0FBSztnQ0FDckUsQ0FBQzs7Ozs7O2dCQUNMLENBQUM7Ozs7WUFDS21PLEdBQWMsRUFBZEEsQ0FBYzttQkFBcEIsUUFBUSxDQUFGQSxjQUFjLENBQUNuTyxLQUFLOzBFQUExQixRQUFRLFdBQW9CLENBQUM7K0JBQ3JCbkMsU0FBUyxFQUNQd1MsTUFBTSxFQUdOQyxlQUFlLEVBV1hDLGVBQWU7Ozs7O2dDQWZyQjFTLFNBQVMsR0FBRyxLQUFLO2dDQUNmd1MsTUFBTSxHQUFHLElBQUksQ0FBQzlHLEdBQUcsR0FBRyxRQUNoQyxHQURvQyxDQUFDO29DQUMzQjFMLFNBQVMsR0FBRyxJQUFJO2dDQUNwQixDQUFDO2dDQUNLeVMsZUFBZSxHQUFHLFFBQzlCLEdBRGtDLENBQUM7b0NBQ3pCLEVBQUUsRUFBRXpTLFNBQVMsRUFBRSxDQUFDO3dDQUNaLEdBQUssQ0FBQzZFLEtBQUssR0FBRyxHQUFHLENBQUM5RSxLQUFLLENBQUUsQ0FBcUMsd0NBQVEsTUFBQyxDQUFQb0MsS0FBSyxFQUFDLENBQUM7d0NBQ3ZFMEMsS0FBSyxDQUFDN0UsU0FBUyxHQUFHLElBQUk7d0NBQ3RCLEtBQUssQ0FBQzZFLEtBQUs7b0NBQ2YsQ0FBQztvQ0FDRCxFQUFFLEVBQUUyTixNQUFNLFdBQVU5RyxHQUFHLEVBQUUsQ0FBQzs4Q0FDakJBLEdBQUcsR0FBRyxJQUFJO29DQUNuQixDQUFDO2dDQUNMLENBQUM7Ozt1Q0FFaUMsSUFBSSxDQUFDOUMsVUFBVSxDQUFDK0osUUFBUSxDQUFDeFEsS0FBSzs7Z0NBQXREdVEsZUFBZTtnQ0FDckJELGVBQWU7NkRBQ1JDLGVBQWU7Ozs7Z0NBRXRCRCxlQUFlO2dDQUNmLEtBQUs7Ozs7Ozs7Ozs7O2dCQUViLENBQUM7Ozs7WUFDRG5CLEdBQVEsRUFBUkEsQ0FBUTttQkFBUkEsUUFBUSxDQUFSQSxRQUFRLENBQUNzQixFQUFFLEVBQUUsQ0FBQzs7Z0JBQ1YsR0FBRyxDQUFDNVMsU0FBUyxHQUFHLEtBQUs7Z0JBQ3JCLEdBQUssQ0FBQ3dTLE1BQU0sR0FBRyxRQUNyQixHQUR5QixDQUFDO29CQUNoQnhTLFNBQVMsR0FBRyxJQUFJO2dCQUNwQixDQUFDO2dCQUNELElBQUksQ0FBQzBMLEdBQUcsR0FBRzhHLE1BQU07Z0JBQ2pCLE1BQU0sQ0FBQ0ksRUFBRSxHQUFHbkwsSUFBSSxDQUFDLFFBQVEsQ0FBUEssSUFBSSxFQUFHLENBQUM7b0JBQ3RCLEVBQUUsRUFBRTBLLE1BQU0sV0FBVTlHLEdBQUcsRUFBRSxDQUFDOzhCQUNqQkEsR0FBRyxHQUFHLElBQUk7b0JBQ25CLENBQUM7b0JBQ0QsRUFBRSxFQUFFMUwsU0FBUyxFQUFFLENBQUM7d0JBQ1osR0FBSyxDQUFDd0ksR0FBRyxHQUFHLEdBQUcsQ0FBQ3pJLEtBQUssQ0FBQyxDQUFpQzt3QkFDdkR5SSxHQUFHLENBQUN4SSxTQUFTLEdBQUcsSUFBSTt3QkFDcEIsS0FBSyxDQUFDd0ksR0FBRztvQkFDYixDQUFDO29CQUNELE1BQU0sQ0FBQ1YsSUFBSTtnQkFDZixDQUFDO1lBQ0wsQ0FBQzs7O1lBQ0s4SCxHQUFpQixFQUFqQkEsQ0FBaUI7bUJBQXZCLFFBQVEsQ0FBRkEsaUJBQWlCLENBQUM5RixPQUFPOzBFQUEvQixRQUFRLFdBQXlCLENBQUM7d0JBQzFCbUQsR0FBRyxFQUNERyxTQUFTLEVBQ1R5RixHQUFHLEVBQ0hDLGlCQUFpQixFQVFqQkMsU0FBUyxFQUtMekYsTUFBTSxFQUNOMEYsVUFBVSxFQUNackQsV0FBVyxFQUNYcEssWUFBWSxFQW9CTjBOLGFBQWEsRUFDTi9FLE1BQU0sRUFBT0MsS0FBSzs7Ozs7Z0NBdkNqQ2YsU0FBUyxHQUFHdlAsU0FBUyxDQUFDQyxXQUFXLENBQUNnTSxPQUFPLENBQUNuRSxFQUFFLElBQUkzSCxXQUFXLENBQUM4TCxPQUFPLENBQUNuRSxFQUFFLElBQUltRSxPQUFPLENBQUNuRSxFQUFFLEVBQUUsSUFBSSxDQUFDakYsTUFBTTs7dUNBQ3JGLElBQUksQ0FBQ2tJLFVBQVUsQ0FBQzJHLGlCQUFpQjs7Z0NBQTdDc0QsR0FBRztnQ0FDSEMsaUJBQWlCLEdBQUdELEdBQUcsQ0FBQ3ZNLElBQUksQ0FBQyxRQUFRLENBQVA0TSxVQUFVLEVBQUcsQ0FBQztvQ0FDOUMsTUFBTSxFQUFFLENBQUMsRUFBRWhVLGFBQWEsRUFBRTBELGVBQWUsRUFBRSxDQUFDLEVBQUV4RCxtQkFBbUIsRUFBRStULGtCQUFrQixDQUFDRCxVQUFVLEdBQUc5RixTQUFTO2dDQUNoSCxDQUFDO29DQUNJMEYsaUJBQWlCOzs7OzZEQUNYLENBQUM7b0NBQ0poRCxJQUFJLEVBQUUsQ0FBTTtnQ0FDaEIsQ0FBQzs7O3VDQUVtQixJQUFJLENBQUNzRCxpQkFBaUIsQ0FBQyxDQUFDO29DQUM1Q0MsYUFBYSxFQUFFdkosT0FBTyxDQUFDbkUsRUFBRTtvQ0FDekIyTixXQUFXLEVBQUV4SixPQUFPLENBQUMrRixLQUFLO2dDQUM5QixDQUFDOztnQ0FIS2tELFNBQVM7dUNBSVY5RixHQUFHLEdBQUc4RixTQUFTLENBQUNRLE9BQU8sTUFBTSxJQUFJLElBQUl0RyxHQUFHLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHQSxHQUFHLENBQUM3TSxVQUFVLENBQUMsQ0FBRzs7OztnQ0FDNUVrTixNQUFNLElBQUksQ0FBQyxFQUFFdk8saUJBQWlCLEVBQUUwTCxnQkFBZ0IsRUFBRSxDQUFDLEVBQUU5TCxvQkFBb0IsRUFBRWtDLG1CQUFtQixDQUFDL0MsV0FBVyxDQUFDaVYsU0FBUyxDQUFDUSxPQUFPLElBQUl2VixXQUFXLENBQUMrVSxTQUFTLENBQUNRLE9BQU8sSUFBSVIsU0FBUyxDQUFDUSxPQUFPLEVBQUUsSUFBSSxDQUFDNVMsT0FBTyxFQUFFTixRQUFRO2dDQUMxTTJTLFVBQVUsSUFBSSxDQUFDLEVBQUUzVSx1QkFBdUIsRUFBRStILHVCQUF1QixDQUFDa0gsTUFBTSxDQUFDak4sUUFBUTs7O2dDQUd2RixFQUFFLEVBQUV5SixPQUFPLENBQUM1RCxLQUFLLENBQUNsQyxRQUFRLENBQUNnUCxVQUFVLEdBQUcsQ0FBQztvQ0FDckNyRCxXQUFXLEdBQUcsSUFBSTtvQ0FDbEJwSyxZQUFZLEdBQUd5TixVQUFVO2dDQUM3QixDQUFDLE1BQU0sQ0FBQztvQ0FDSnpOLFlBQVksR0FBR1UsbUJBQW1CLENBQUMrTSxVQUFVLEVBQUVsSixPQUFPLENBQUM1RCxLQUFLO29DQUM1RCxFQUFFLEVBQUVYLFlBQVksS0FBSytILE1BQU0sQ0FBQ2pOLFFBQVEsSUFBSXlKLE9BQU8sQ0FBQzVELEtBQUssQ0FBQ2xDLFFBQVEsQ0FBQ3VCLFlBQVksR0FBRyxDQUFDO3dDQUMzRW9LLFdBQVcsR0FBRyxJQUFJO29DQUN0QixDQUFDO2dDQUNMLENBQUM7NkRBQ00sQ0FBQztvQ0FDSkcsSUFBSSxFQUFFLENBQVM7b0NBQ2Y5SyxNQUFNLEVBQUVzSSxNQUFNLENBQUNqTixRQUFRO29DQUN2QnlNLFFBQVEsRUFBRVEsTUFBTTtvQ0FDaEJxQyxXQUFXLEVBQVhBLFdBQVc7b0NBQ1hwSyxZQUFZLEVBQVpBLFlBQVk7Z0NBQ2hCLENBQUM7O3FDQUVEd04sU0FBUyxDQUFDUyxRQUFROzs7O3FDQUNkVCxTQUFTLENBQUNTLFFBQVEsQ0FBQ3BULFVBQVUsQ0FBQyxDQUFHOzs7O2dDQUMzQjZTLGFBQWEsSUFBSSxDQUFDLEVBQUU1VSx1QkFBdUIsRUFBRStILHVCQUF1QixFQUFFLENBQUMsRUFBRXpILG9CQUFvQixFQUFFa0MsbUJBQW1CLENBQUMvQyxXQUFXLENBQUNpVixTQUFTLENBQUNTLFFBQVEsSUFBSXhWLFdBQVcsQ0FBQytVLFNBQVMsQ0FBQ1MsUUFBUSxJQUFJVCxTQUFTLENBQUNTLFFBQVEsRUFBRSxJQUFJLENBQUM3UyxPQUFPLEVBQUVOLFFBQVE7O3dDQUNsTXFGLFlBQVksQ0FBQyxJQUFJLEVBQUV1TixhQUFhLEVBQUVBLGFBQWEsR0FBdkUvRSxNQUFNLFNBQVh0TSxHQUFHLEVBQWV1TSxLQUFLLFNBQVR4SSxFQUFFOzZEQUNqQixDQUFDO29DQUNKbUssSUFBSSxFQUFFLENBQVU7b0NBQ2hCNUIsTUFBTSxFQUFOQSxNQUFNO29DQUNOQyxLQUFLLEVBQUxBLEtBQUs7Z0NBQ1QsQ0FBQzs7NkRBRUUsQ0FBQztvQ0FDSjJCLElBQUksRUFBRSxDQUFVO29DQUNoQjlCLFdBQVcsRUFBRStFLFNBQVMsQ0FBQ1MsUUFBUTtnQ0FDbkMsQ0FBQzs7cUNBRURULFNBQVMsQ0FBQ1UsT0FBTzs7Ozs2REFDVixDQUFDO29DQUNKM0QsSUFBSSxFQUFFLENBQVM7Z0NBQ25CLENBQUM7OzZEQUVFLENBQUM7b0NBQ0pBLElBQUksRUFBRSxDQUFNO2dDQUNoQixDQUFDOzs7Ozs7Z0JBQ0wsQ0FBQzs7OztZQUNEc0QsR0FBaUIsRUFBakJBLENBQWlCO21CQUFqQkEsUUFBUSxDQUFSQSxpQkFBaUIsQ0FBQ3ZRLE1BQU0sRUFBRSxDQUFDOztnQkFDdkIsR0FBSyxDQUFHd1EsYUFBYSxHQUEyQnhRLE1BQU0sQ0FBOUN3USxhQUFhLGlCQUEyQnhRLE1BQU0sQ0FBOUJ5USxXQUFXLEVBQVhBLFdBQVcsNkJBQUUsS0FBSztnQkFDMUMsR0FBSyxDQUF1QixHQUE0QyxHQUE1QyxHQUFHLENBQUN0UixHQUFHLENBQUNxUixhQUFhLEVBQUV6TSxNQUFNLENBQUN5QixRQUFRLENBQUNuRSxJQUFJLEdBQXpEb0UsUUFBUSxHQUFNLEdBQTRDLENBQWhFcEUsSUFBSTtnQkFDWixFQUFFLEVBdm9DVixLQXVvQ3lHLEVBQUUsRUFFbEc7Z0JBQ0QsTUFBTSxDQUFDcUQsS0FBSyxDQUFDOEwsYUFBYSxFQUFFLENBQUM7b0JBQ3pCMUcsTUFBTSxFQUFFLENBQU07b0JBQ2RuRixXQUFXLEVBQUUsQ0FBYTtvQkFDMUJtTSxPQUFPLEVBQUUsQ0FBQzt3QkFDTixDQUF3Qix5QkFBRSxDQUFHO29CQUNqQyxDQUFDO2dCQUNMLENBQUMsRUFBRWxNLElBQUksQ0FBQyxRQUFRLENBQVBDLEdBQUcsRUFBRyxDQUFDO29CQUNaLEVBQUUsR0FBR0EsR0FBRyxDQUFDQyxFQUFFLEVBQUUsQ0FBQzt3QkFDVixLQUFLLENBQUMsR0FBRyxDQUFDNUgsS0FBSyxDQUFFLENBQTJCO29CQUNoRCxDQUFDO29CQUNELE1BQU0sQ0FBQyxDQUFDO3dCQUNKeVQsUUFBUSxFQUFFOUwsR0FBRyxDQUFDaU0sT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBVTt3QkFDcENILE9BQU8sRUFBRS9MLEdBQUcsQ0FBQ2lNLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDLENBQXNCO3dCQUMvQ04sT0FBTyxFQUFFN0wsR0FBRyxDQUFDaU0sT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBc0I7b0JBQ25ELENBQUM7Z0JBQ0wsQ0FBQyxFQUFFbk0sSUFBSSxDQUFDLFFBQVEsQ0FBUEssSUFBSSxFQUFHLENBQUM7b0JBQ2IsRUFBRSxFQUFFd0wsV0FBVyxFQUFFLENBQUM7OEJBQ1RqSyxHQUFHLENBQUNmLFFBQVEsSUFBSVIsSUFBSTtvQkFDN0IsQ0FBQztvQkFDRCxNQUFNLENBQUNBLElBQUk7Z0JBQ2YsQ0FBQyxFQUFFUyxLQUFLLENBQUMsUUFBUSxDQUFQQyxHQUFHLEVBQUcsQ0FBQztvQkFDYixNQUFNLFFBQU1hLEdBQUcsQ0FBQ2YsUUFBUTtvQkFDeEIsS0FBSyxDQUFDRSxHQUFHO2dCQUNiLENBQUM7WUFDTCxDQUFDOzs7WUFDRHdJLEdBQWUsRUFBZkEsQ0FBZTttQkFBZkEsUUFBUSxDQUFSQSxlQUFlLENBQUNqSSxTQUFTLEVBQUUrSyxHQUFHLEVBQUUsQ0FBQztnQkFDN0IsR0FBSyxDQUF1QixHQUF3QixHQUF4QixJQUFJLENBQUMvSSxVQUFVLENBQUMsQ0FBTyxTQUFoQ2xDLEdBQUcsR0FBTSxHQUF3QixDQUE1Q0UsU0FBUztnQkFDakIsR0FBSyxDQUFDZ0wsT0FBTyxHQUFHLElBQUksQ0FBQ3BJLFFBQVEsQ0FBQzlDLEdBQUc7Z0JBQ2pDaUwsR0FBRyxDQUFDQyxPQUFPLEdBQUdBLE9BQU87Z0JBQ3JCLE1BQU0sRUFBRSxDQUFDLEVBQUVsVixNQUFNLEVBQUVtVixtQkFBbUIsQ0FBQ25MLEdBQUcsRUFBRSxDQUFDO29CQUN6Q2tMLE9BQU8sRUFBUEEsT0FBTztvQkFDUGhMLFNBQVMsRUFBVEEsU0FBUztvQkFDVDlFLE1BQU0sRUFBRSxJQUFJO29CQUNaNlAsR0FBRyxFQUFIQSxHQUFHO2dCQUNQLENBQUM7WUFDTCxDQUFDOzs7WUFDRC9FLEdBQWtCLEVBQWxCQSxDQUFrQjttQkFBbEJBLFFBQVEsQ0FBUkEsa0JBQWtCLENBQUNwSixFQUFFLEVBQUV3SCxVQUFVLEVBQUUsQ0FBQztnQkFDaEMsRUFBRSxFQUFFLElBQUksQ0FBQ3pCLEdBQUcsRUFBRSxDQUFDO29CQUNYaEQsTUFBTSxDQUFDMkMsTUFBTSxDQUFDNEQsSUFBSSxDQUFDLENBQWtCLG1CQUFFcFAsc0JBQXNCLElBQUk4RixFQUFFLEVBQUV3SCxVQUFVO29CQUMvRSxJQUFJLENBQUN6QixHQUFHO29CQUNSLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUk7Z0JBQ25CLENBQUM7WUFDTCxDQUFDOzs7WUFDRHlELEdBQU0sRUFBTkEsQ0FBTTttQkFBTkEsUUFBUSxDQUFSQSxNQUFNLENBQUNySCxJQUFJLEVBQUUwRyxXQUFXLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxDQUFDLElBQUksQ0FBQy9DLEdBQUcsQ0FBQzNELElBQUksRUFBRSxJQUFJLENBQUNpRCxVQUFVLENBQUMsQ0FBTyxRQUFFaEMsU0FBUyxFQUFFeUYsV0FBVztZQUN6RSxDQUFDOzs7V0F4M0JDOUYsTUFBTTs7QUEwM0JaQSxNQUFNLENBQUMyQyxNQUFNLElBQUksQ0FBQyxFQUFFek0sS0FBSyxFQUFFUixPQUFPO0FBQ2xDWCxrQkFBZSxHQUFHaUwsTUFBTSxDQUV4QixDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXREb21haW5Mb2NhbGUgPSBnZXREb21haW5Mb2NhbGU7XG5leHBvcnRzLmFkZExvY2FsZSA9IGFkZExvY2FsZTtcbmV4cG9ydHMuZGVsTG9jYWxlID0gZGVsTG9jYWxlO1xuZXhwb3J0cy5oYXNCYXNlUGF0aCA9IGhhc0Jhc2VQYXRoO1xuZXhwb3J0cy5hZGRCYXNlUGF0aCA9IGFkZEJhc2VQYXRoO1xuZXhwb3J0cy5kZWxCYXNlUGF0aCA9IGRlbEJhc2VQYXRoO1xuZXhwb3J0cy5pc0xvY2FsVVJMID0gaXNMb2NhbFVSTDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcyA9IGludGVycG9sYXRlQXM7XG5leHBvcnRzLnJlc29sdmVIcmVmID0gcmVzb2x2ZUhyZWY7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbnZhciBfcm91dGVMb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL21pdHRcIikpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfaXNEeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcGFyc2VSZWxhdGl2ZVVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcmVzb2x2ZVJld3JpdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLXJld3JpdGVzXCIpKTtcbnZhciBfcm91dGVNYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbnZhciBfcm91dGVSZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xudmFyIF9nZXRNaWRkbGV3YXJlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbWlkZGxld2FyZS1yZWdleFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmxldCBkZXRlY3REb21haW5Mb2NhbGU7XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG59XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykgfHwgIXByZWZpeCkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goYCR7cHJlZml4fSR7cGF0aG5hbWV9YCkgKyBwYXRoLnN1YnN0cihwYXRobmFtZS5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGxvY2FsZSA9IGxvY2FsZSB8fCAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKTtcbiAgICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke2Jhc2VQYXRoIHx8ICcnfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRMb2NhbGUocGF0aCwgbG9jYWxlLCBkZWZhdWx0TG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAhcGF0aExvd2VyLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlTG93ZXIgKyAnLycpICYmIHBhdGhMb3dlciAhPT0gJy8nICsgbG9jYWxlTG93ZXIgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSkgOiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGRlbExvY2FsZShwYXRoLCBsb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb2NhbGUgJiYgKHBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSB8fCBwYXRoTG93ZXIgPT09ICcvJyArIGxvY2FsZUxvd2VyKSA/IChwYXRobmFtZS5sZW5ndGggPT09IGxvY2FsZS5sZW5ndGggKyAxID8gJy8nIDogJycpICsgcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpIDogcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aCkge1xuICAgIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgICBpZiAocXVlcnlJbmRleCA+IC0xIHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKTtcbn1cbmZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGgpIHtcbiAgICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICAgIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKTtcbn1cbmZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpO1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmwpIHtcbiAgICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykgfHwgdXJsLnN0YXJ0c1dpdGgoJyMnKSB8fCB1cmwuc3RhcnRzV2l0aCgnPycpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkge1xuICAgIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8IC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeTtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpO1xuICAgIGlmICghcGFyYW1zLmV2ZXJ5KChwYXJhbSk9PntcbiAgICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnO1xuICAgICAgICBjb25zdCB7IHJlcGVhdCAsIG9wdGlvbmFsICB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV07XG4gICAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWA7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJiAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID0gaW50ZXJwb2xhdGVkUm91dGUucmVwbGFjZShyZXBsYWNlZCwgcmVwZWF0ID8gdmFsdWUubWFwKC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgKHNlZ21lbnQpPT5lbmNvZGVVUklDb21wb25lbnQoc2VnbWVudClcbiAgICAgICAgKS5qb2luKCcvJykgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCAnLycpO1xuICAgIH0pKSB7XG4gICAgICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcbiAgICAgICAgO1xuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZmlsdGVyZWRRdWVyeSA9IHtcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRRdWVyeTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVIcmVmKHJvdXRlciwgaHJlZiwgcmVzb2x2ZUFzKSB7XG4gICAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgICBsZXQgYmFzZTtcbiAgICBsZXQgdXJsQXNTdHJpbmcgPSB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZik7XG4gICAgLy8gcmVwZWF0ZWQgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMgaW4gdGhlIFVSTCBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGludmFsaWQgYW5kIHdpbGwgbmV2ZXIgbWF0Y2ggYSBOZXh0LmpzIHBhZ2UvZmlsZVxuICAgIGNvbnN0IHVybFByb3RvTWF0Y2ggPSB1cmxBc1N0cmluZy5tYXRjaCgvXlthLXpBLVpdezEsfTpcXC9cXC8vKTtcbiAgICBjb25zdCB1cmxBc1N0cmluZ05vUHJvdG8gPSB1cmxQcm90b01hdGNoID8gdXJsQXNTdHJpbmcuc3Vic3RyKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KCc/Jyk7XG4gICAgaWYgKCh1cmxQYXJ0c1swXSB8fCAnJykubWF0Y2goLyhcXC9cXC98XFxcXCkvKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIG5leHQvcm91dGVyOiAke3VybEFzU3RyaW5nfSwgcmVwZWF0ZWQgZm9yd2FyZC1zbGFzaGVzICgvLykgb3IgYmFja3NsYXNoZXMgXFxcXCBhcmUgbm90IHZhbGlkIGluIHRoZSBocmVmYCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSAoMCwgX3V0aWxzKS5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsQXNTdHJpbmdOb1Byb3RvKTtcbiAgICAgICAgdXJsQXNTdHJpbmcgPSAodXJsUHJvdG9NYXRjaCA/IHVybFByb3RvTWF0Y2hbMF0gOiAnJykgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwodXJsQXNTdHJpbmcuc3RhcnRzV2l0aCgnIycpID8gcm91dGVyLmFzUGF0aCA6IHJvdXRlci5wYXRobmFtZSwgJ2h0dHA6Ly9uJyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTCgnLycsICdodHRwOi8vbicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpO1xuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goZmluYWxVcmwucGF0aG5hbWUpO1xuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJztcbiAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nKS5zZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCAsIHBhcmFtcyAgfSA9IGludGVycG9sYXRlQXMoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKSA6IGZpbmFsVXJsLmhyZWY7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcbiAgICB9IGNhdGNoIChfMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgY29uc3QgaHJlZkhhZE9yaWdpbiA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFnZSkgJiYgKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge1xuICAgIH1cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgfSkudGhlbigocmVzKT0+e1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIsIGluZmxpZ2h0Q2FjaGUsIHBlcnNpc3RDYWNoZSkge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAgICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAgICAgLy8gbG9vcC5cbiAgICAgICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikubWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuY2xhc3MgUm91dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gICAgICAgIHRoaXMuc2RjID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbi1mbGlnaHQgU2VydmVyIERhdGEgUmVxdWVzdHMsIGZvciBkZWR1cGluZ1xuICAgICAgICB0aGlzLnNkciA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW4tZmxpZ2h0IG1pZGRsZXdhcmUgcHJlZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgIHRoaXMuc2RlID0ge1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pZHggPSAwO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMpLmdldFVSTCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGlkeCAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lkeCA9IGlkeDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICB0aGlzLnJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcztcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFjaztcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICB0aGlzLmlzUHJldmlldyA9ICEhaXNQcmV2aWV3O1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMpLmdldFVSTCgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHB1c2godXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNob3VsZFJlc29sdmVIcmVmID0gb3B0aW9ucy5faCB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCBwYXRoTm9RdWVyeUhhc2godXJsKSA9PT0gcGF0aE5vUXVlcnlIYXNoKGFzKTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICBpZiAob3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gdGhpcy5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChyZWYgPSB0aGlzLmxvY2FsZXMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmluY2x1ZGVzKHRoaXMubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHthZGRCYXNlUGF0aChgJHt0aGlzLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke3RoaXMubG9jYWxlfWB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nKX1gO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSBhZGRCYXNlUGF0aChhZGRMb2NhbGUoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgbGV0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IHRoaXMubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmVMaXN0KCksIFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoY2xlYW5lZEFzLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpXG4gICAgICAgICAgICAgICAgLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICsgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIGNhY2hlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGVmZmVjdC5hc1BhdGg7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBlZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlZmZlY3QudHlwZSA9PT0gJ3JlZGlyZWN0JyAmJiBlZmZlY3QubmV3QXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIGVmZmVjdC5uZXdVcmwsIGVmZmVjdC5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGVmZmVjdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWZyZXNoJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3Nob3VsZEludGVycG9sYXRlID8gYEludGVycG9sYXRpbmcgaHJlZmAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICsgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArIGBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLyR7c2hvdWxkSW50ZXJwb2xhdGUgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCcgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIH0sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcmVzb2x2ZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICBsZXQgeyBlcnJvciAsIHByb3BzICwgX19OX1NTRyAsIF9fTl9TU1AgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgoX19OX1NTRyB8fCBfX05fU1NQKSAmJiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5wYWdlUHJvcHMgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlzUHJldmlldyA9ICEhcHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0JztcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhub3RGb3VuZFJvdXRlLCBub3RGb3VuZFJvdXRlLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLl9oICYmIHBhdGhuYW1lID09PSAnL19lcnJvcicgJiYgKChyZWYgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKHJlZjEgPSByZWYucGFnZVByb3BzKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZTtcbiAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCkgIT09IG51bGwgJiYgX3Njcm9sbCAhPT0gdm9pZCAwID8gX3Njcm9sbCA6ICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGNsZWFuZWRBcywgcm91dGVJbmZvLCBmb3JjZWRTY3JvbGwgIT09IG51bGwgJiYgZm9yY2VkU2Nyb2xsICE9PSB2b2lkIDAgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbCkuY2F0Y2goKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyMSkgJiYgZXJyMS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnIxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8ICgwLCBfdXRpbHMpLmdldFVSTCgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgJycsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVMb2FkZXIpLmlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBDb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgc3R5bGVTaGVldHM7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHN0eWxlU2hlZXRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICh7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdSb3V0ZUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gY2FuIG9ubHkgdXNlIG5vbi1pbml0aWFsIHJvdXRlIGluZm9cbiAgICAgICAgICAgIC8vIGNhbm5vdCByZXVzZSByb3V0ZSBpbmZvIGluIGRldmVsb3BtZW50IHNpbmNlIGl0IGNhbiBjaGFuZ2UgYWZ0ZXIgSE1SXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgISgnaW5pdGlhbCcgaW4gZXhpc3RpbmdSb3V0ZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUm91dGVJbmZvID0gZXhpc3RpbmdSb3V0ZUluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHsgQ29tcG9uZW50ICwgX19OX1NTRyAsIF9fTl9TU1AgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YUhyZWY7XG4gICAgICAgICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgcmVzb2x2ZWRBcywgX19OX1NTRywgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhKCgpPT5fX05fU1NHIHx8IF9fTl9TU1AgPyBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyLCBfX05fU1NHID8gdGhpcy5zZGMgOiB0aGlzLnNkciwgISFfX05fU1NHKSA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycikgPyBlcnIgOiBuZXcgRXJyb3IoZXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGFzO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJyk7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCA9IHVybCwgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IGF3YWl0ICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSk7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZVJld3JpdGVzKS5kZWZhdWx0KGFkZEJhc2VQYXRoKGFkZExvY2FsZShhc1BhdGgsIHRoaXMubG9jYWxlKSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpXG4gICAgICAgICAgICAsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWZmZWN0cyA9IGF3YWl0IHRoaXMuX3ByZWZsaWdodFJlcXVlc3Qoe1xuICAgICAgICAgICAgYXM6IGFzUGF0aCxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWZmZWN0cy50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGVmZmVjdHMucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3RzLnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmVmZmVjdHMucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZWZmZWN0cy5hc1BhdGg7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEodGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHVybCwgcmVzb2x2ZWRBcywgdHJ1ZSwgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9jYWxlIDogdGhpcy5sb2NhbGUpLCBmYWxzZSwgdGhpcy5zZGMsIHRydWUpIDogZmFsc2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSwgXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IHRoaXMuY2xjID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImApO1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9wcmVmbGlnaHRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKGhhc0Jhc2VQYXRoKG9wdGlvbnMuYXMpID8gZGVsQmFzZVBhdGgob3B0aW9ucy5hcykgOiBvcHRpb25zLmFzLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGZucyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlTGlzdCgpO1xuICAgICAgICBjb25zdCByZXF1aXJlc1ByZWZsaWdodCA9IGZucy5zb21lKChtaWRkbGV3YXJlKT0+e1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoKDAsIF9nZXRNaWRkbGV3YXJlUmVnZXgpLmdldE1pZGRsZXdhcmVSZWdleChtaWRkbGV3YXJlKSkoY2xlYW5lZEFzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVxdWlyZXNQcmVmbGlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZsaWdodCA9IGF3YWl0IHRoaXMuX2dldFByZWZsaWdodERhdGEoe1xuICAgICAgICAgICAgcHJlZmxpZ2h0SHJlZjogb3B0aW9ucy5hcyxcbiAgICAgICAgICAgIHNob3VsZENhY2hlOiBvcHRpb25zLmNhY2hlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKHJlZiA9IHByZWZsaWdodC5yZXdyaXRlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpID8gZGVsQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpIDogcHJlZmxpZ2h0LnJld3JpdGUsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZnNQYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGFyc2VkLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVkUGFnZTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIG9wdGlvbnMucGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IHBhcnNlZC5wYXRobmFtZSAmJiBvcHRpb25zLnBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jld3JpdGUnLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogcGFyc2VkLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWQsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3QpIHtcbiAgICAgICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3Quc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5SZWRpcmVjdCA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHByZWZsaWdodC5yZWRpcmVjdCkgPyBkZWxCYXNlUGF0aChwcmVmbGlnaHQucmVkaXJlY3QpIDogcHJlZmxpZ2h0LnJlZGlyZWN0LCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsICwgYXM6IG5ld0FzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIGNsZWFuUmVkaXJlY3QsIGNsZWFuUmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCxcbiAgICAgICAgICAgICAgICAgICAgbmV3QXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBwcmVmbGlnaHQucmVkaXJlY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZsaWdodC5yZWZyZXNoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWZyZXNoJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcmVmbGlnaHREYXRhKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHByZWZsaWdodEhyZWYgLCBzaG91bGRDYWNoZSA9ZmFsc2UgIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKHByZWZsaWdodEhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgIXRoaXMuaXNQcmV2aWV3ICYmIHNob3VsZENhY2hlICYmIHRoaXMuc2RlW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkZVtjYWNoZUtleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChwcmVmbGlnaHRIcmVmLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICd4LW1pZGRsZXdhcmUtcHJlZmxpZ2h0JzogJzEnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlZmxpZ2h0IHJlcXVlc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IHJlcy5oZWFkZXJzLmdldCgnTG9jYXRpb24nKSxcbiAgICAgICAgICAgICAgICByZWZyZXNoOiByZXMuaGVhZGVycy5oYXMoJ3gtbWlkZGxld2FyZS1yZWZyZXNoJyksXG4gICAgICAgICAgICAgICAgcmV3cml0ZTogcmVzLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtcmV3cml0ZScpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZGVbY2FjaGVLZXldID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRDb21wb25lbnRMb2FkKGFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldERvbWFpbkxvY2FsZSIsImFkZExvY2FsZSIsImRlbExvY2FsZSIsImhhc0Jhc2VQYXRoIiwiYWRkQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsImlzTG9jYWxVUkwiLCJpbnRlcnBvbGF0ZUFzIiwicmVzb2x2ZUhyZWYiLCJkZWZhdWx0IiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIiwiX3JvdXRlTG9hZGVyIiwiX2lzRXJyb3IiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2Rlbm9ybWFsaXplUGFnZVBhdGgiLCJfbm9ybWFsaXplTG9jYWxlUGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzRHluYW1pYyIsIl9wYXJzZVJlbGF0aXZlVXJsIiwiX3F1ZXJ5c3RyaW5nIiwiX3Jlc29sdmVSZXdyaXRlcyIsIl9yb3V0ZU1hdGNoZXIiLCJfcm91dGVSZWdleCIsIl9nZXRNaWRkbGV3YXJlUmVnZXgiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJiYXNlUGF0aCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInBhdGhOb1F1ZXJ5SGFzaCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwic3Vic3RyIiwibGVuZ3RoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0ZWRMb2NhbGUiLCJkZXRlY3RlZERvbWFpbiIsInVuZGVmaW5lZCIsImh0dHAiLCJkb21haW4iLCJkZWZhdWx0TG9jYWxlIiwicGF0aExvd2VyIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVMb3dlciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwiaGFzaEluZGV4Iiwic3Vic3RyaW5nIiwic2xpY2UiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJfIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInJlcGVhdCIsIm9wdGlvbmFsIiwicmVwbGFjZWQiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwibWFwIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJyZXN1bHQiLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJmaWx0ZXJlZFF1ZXJ5IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsIm5vcm1hbGl6ZWRVcmwiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJhc1BhdGgiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwiaGFzaCIsInJlc29sdmVkSHJlZiIsIl8xIiwic3RyaXBPcmlnaW4iLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkQXMiLCJocmVmSGFkT3JpZ2luIiwiYXNIYWRPcmlnaW4iLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwic29tZSIsInBhZ2UiLCJyZSIsInRlc3QiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInRoZW4iLCJyZXMiLCJvayIsInN0YXR1cyIsImpzb24iLCJkYXRhIiwibm90Rm91bmQiLCJmZXRjaE5leHREYXRhIiwiZGF0YUhyZWYiLCJpc1NlcnZlclJlbmRlciIsImluZmxpZ2h0Q2FjaGUiLCJwZXJzaXN0Q2FjaGUiLCJsb2NhdGlvbiIsImNhY2hlS2V5IiwiY2F0Y2giLCJlcnIiLCJtYXJrQXNzZXRFcnJvciIsIlJvdXRlciIsImluaXRpYWxQcm9wcyIsInBhZ2VMb2FkZXIiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImlzUHJldmlldyIsInNkYyIsInNkciIsInNkZSIsIl9pZHgiLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJnZXRVUkwiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJvcHRpb25zIiwiaWR4IiwiSlNPTiIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwicGFyc2UiLCJwYXJzZVJlbGF0aXZlVXJsIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiY29tcG9uZW50cyIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwic3R5bGVTaGVldHMiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0Iiwic3ViIiwiY2xjIiwiX3dyYXBBcHAiLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJpc0xvY2FsZURvbWFpbiIsImhvc3RuYW1lIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwicmVsb2FkIiwiYmFjayIsInB1c2giLCJtZXRob2QiLCJzaG91bGRSZXNvbHZlSHJlZiIsInByZXZMb2NhbGUiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsInJlZiIsImFzTm9CYXNlUGF0aCIsInJvdXRlUHJvcHMiLCJjbGVhbmVkQXMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWQiLCJyZXdyaXRlcyIsInJld3JpdGVzUmVzdWx0IiwiZWZmZWN0Iiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJyZWYxIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwibmV3VXJsIiwibmV3QXMiLCJub3RGb3VuZFJvdXRlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsIl9oIiwiUHJvbWlzZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiX2luRmxpZ2h0Um91dGUiLCJhYm9ydENvbXBvbmVudExvYWQiLCJvbmx5QUhhc2hDaGFuZ2UiLCJlbWl0Iiwic2Nyb2xsVG9IYXNoIiwibm90aWZ5IiwiYWxsIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZUxpc3QiLCJfX3Jld3JpdGVzIiwidXJsSXNOZXciLCJwIiwibWF0Y2hlZFBhZ2UiLCJfcHJlZmxpZ2h0UmVxdWVzdCIsImNhY2hlIiwidHlwZSIsImZpbHRlciIsIndhcm4iLCJnZXRSb3V0ZUluZm8iLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsInN0YXR1c0NvZGUiLCJzY3JvbGwiLCJzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJleGlzdGluZ1JvdXRlSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsIm1vZCIsImdldERhdGFIcmVmIiwiX2dldERhdGEiLCJiZWZvcmVQb3BTdGF0ZSIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJwcmVmZXRjaCIsImVmZmVjdHMiLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiY2FuY2VsIiwiaGFuZGxlQ2FuY2VsbGVkIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsImZucyIsInJlcXVpcmVzUHJlZmxpZ2h0IiwicHJlZmxpZ2h0IiwiZnNQYXRobmFtZSIsImNsZWFuUmVkaXJlY3QiLCJtaWRkbGV3YXJlIiwiZ2V0TWlkZGxld2FyZVJlZ2V4IiwiX2dldFByZWZsaWdodERhdGEiLCJwcmVmbGlnaHRIcmVmIiwic2hvdWxkQ2FjaGUiLCJyZXdyaXRlIiwicmVkaXJlY3QiLCJyZWZyZXNoIiwicmVzb2x2ZSIsImhlYWRlcnMiLCJnZXQiLCJoYXMiLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatUrl = formatUrl;\nvar querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\"));\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    var auth = urlObj.auth, hostname = urlObj.hostname;\n    var protocol = urlObj.protocol || '';\n    var pathname = urlObj.pathname || '';\n    var hash = urlObj.hash || '';\n    var query = urlObj.query || '';\n    var host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\".concat(hostname, \"]\") : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(querystring.urlQueryToSearchParams(query));\n    }\n    var search = urlObj.search || query && \"?\".concat(query) || '';\n    if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanM/NTk2My5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHRSxTQUFTO0FBQzdCLEdBQUcsQ0FBQ0MsV0FBVyxHQUFHQyx1QkFBdUIsQ0FBQ0MsbUJBQU8sQ0FBQywyRkFBZTtTQUN4REQsdUJBQXVCLENBQUNFLEdBQUcsRUFBRSxDQUFDO0lBQ25DLEVBQUUsRUFBRUEsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsRUFBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQ0QsR0FBRztJQUNkLENBQUMsTUFBTSxDQUFDO1FBQ0osR0FBRyxDQUFDRSxNQUFNLEdBQUcsQ0FBQztRQUNkLENBQUM7UUFDRCxFQUFFLEVBQUVGLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNkLEdBQUcsQ0FBQyxHQUFHLENBQUNHLEdBQUcsSUFBSUgsR0FBRyxDQUFDLENBQUM7Z0JBQ2hCLEVBQUUsRUFBRVIsTUFBTSxDQUFDWSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTixHQUFHLEVBQUVHLEdBQUcsR0FBRyxDQUFDO29CQUNqRCxHQUFHLENBQUNJLElBQUksR0FBR2YsTUFBTSxDQUFDQyxjQUFjLElBQUlELE1BQU0sQ0FBQ2dCLHdCQUF3QixHQUFHaEIsTUFBTSxDQUFDZ0Isd0JBQXdCLENBQUNSLEdBQUcsRUFBRUcsR0FBRyxJQUFJLENBQUM7b0JBQ25ILENBQUM7b0JBQ0QsRUFBRSxFQUFFSSxJQUFJLENBQUNFLEdBQUcsSUFBSUYsSUFBSSxDQUFDRyxHQUFHLEVBQUUsQ0FBQzt3QkFDdkJsQixNQUFNLENBQUNDLGNBQWMsQ0FBQ1MsTUFBTSxFQUFFQyxHQUFHLEVBQUVJLElBQUk7b0JBQzNDLENBQUMsTUFBTSxDQUFDO3dCQUNKTCxNQUFNLENB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a0I7SUFDdkRNLE1BQU0sR0FBR0EsTUFBTSxDQUFDTCxPQUFPLENBQUMsQ0FBRyxJQUFFLENBQUs7SUFDbEMsTUFBTSxDQUFFLEdBQWFGLE1BQUksQ0FBZkosUUFBUSxFQUFVQyxNQUFRLENBQWZHLElBQUksRUFBY08sTUFBTSxDQUFqQlYsUUFBUSxFQUFZQyxNQUFJLENBQWJTLE1BQU0sRUFBUSxPQUFMVCxJQUFJO0FBQ3hELENBQUMsQ0FFcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvcm1hdFVybCA9IGZvcm1hdFVybDtcbnZhciBxdWVyeXN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge1xuICAgICAgICB9O1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cbn1cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87XG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqKSB7XG4gICAgbGV0IHsgYXV0aCAsIGhvc3RuYW1lICB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJztcbiAgICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJztcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJyc7XG4gICAgbGV0IGhvc3QgPSBmYWxzZTtcbiAgICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnO1xuICAgIGlmICh1cmxPYmouaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0O1xuICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICAgICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgYD8ke3F1ZXJ5fWAgfHwgJyc7XG4gICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuICAgIGlmICh1cmxPYmouc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSAnJztcbiAgICB9XG4gICAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtdXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZvcm1hdFVybCIsInF1ZXJ5c3RyaW5nIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsIm5ld09iaiIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJkZWZhdWx0Iiwic2xhc2hlZFByb3RvY29scyIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsInN1YnN0ciIsInNsYXNoZXMiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nfunction parseRelativeUrl(url, base) {\n    var globalBase = new URL( false ? 0 : (0, _utils).getLocationOrigin());\n    var resolvedBase = base ? new URL(base, globalBase) : globalBase;\n    var ref = new URL(url, resolvedBase), pathname = ref.pathname, searchParams = ref.searchParams, search = ref.search, hash = ref.hash, href = ref.href, origin = ref.origin;\n    if (origin !== globalBase.origin) {\n        throw new Error(\"invariant: invalid relative URL, router received \".concat(url));\n    }\n    return {\n        pathname: pathname,\n        query: (0, _querystring).searchParamsToUrlQuery(searchParams),\n        search: search,\n        hash: hash,\n        href: href.slice(globalBase.origin.length)\n    };\n} //# sourceMappingURL=parse-relative-url.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHdCQUF3QixHQUFHRSxnQkFBZ0I7QUFDM0MsR0FBRyxDQUFDQyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsaUVBQWE7QUFDbEMsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMsMkZBQWU7U0FDakNGLGdCQUFnQixDQUFDSSxHQUFHLEVBQUVDLElBQUksRUFBRSxDQUFDO0lBQ2xDLEdBQUssQ0FBQ0MsVUFBVSxHQUFHLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDLE1BQTZCLEdBQUcsQ0FBVSxJQUFJLENBQUMsRUFBRU4sTUFBTSxFQUFFTyxpQkFBaUI7SUFDckcsR0FBSyxDQUFDQyxZQUFZLEdBQUdKLElBQUksR0FBRyxHQUFHLENBQUNFLEdBQUcsQ0FBQ0YsSUFBSSxFQUFFQyxVQUFVLElBQUlBLFVBQVU7SUFDbEUsR0FBSyxDQUFnRSxHQUEwQixHQUExQixHQUFHLENBQUNDLEdBQUcsQ0FBQ0gsR0FBRyxFQUFFSyxZQUFZLEdBQXRGQyxRQUFRLEdBQXFELEdBQTBCLENBQXZGQSxRQUFRLEVBQUdDLFlBQVksR0FBc0MsR0FBMEIsQ0FBNUVBLFlBQVksRUFBR0MsTUFBTSxHQUE2QixHQUEwQixDQUE3REEsTUFBTSxFQUFHQyxJQUFJLEdBQXNCLEdBQTBCLENBQXBEQSxJQUFJLEVBQUdDLElBQUksR0FBZSxHQUEwQixDQUE3Q0EsSUFBSSxFQUFHQyxNQUFNLEdBQU0sR0FBMEIsQ0FBdENBLE1BQU07SUFDL0QsRUFBRSxFQUFFQSxNQUFNLEtBQUtULFVBQVUsQ0FBQ1MsTUFBTSxFQUFFLENBQUM7UUFDL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFFLENBQWlELG1EQUFNLE9BQUpaLEdBQUc7SUFDM0UsQ0FBQztJQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ0pNLFFBQVEsRUFBUkEsUUFBUTtRQUNSTyxLQUFLLEdBQUcsQ0FBQyxFQUFFZCxZQUFZLEVBQUVlLHNCQUFzQixDQUFDUCxZQUFZO1FBQzVEQyxNQUFNLEVBQU5BLE1BQU07UUFDTkMsSUFBSSxFQUFKQSxJQUFJO1FBQ0pDLElBQUksRUFBRUEsSUFBSSxDQUFDSyxLQUFLLENBQUNiLFVBQVUsQ0FBQ1MsTUFBTSxDQUFDSyxNQUFNO0lBQzdDLENBQUM7QUFDTCxDQUFDLENBRTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLmpzPzRlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlUmVsYXRpdmVVcmwgPSBwYXJzZVJlbGF0aXZlVXJsO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi9xdWVyeXN0cmluZ1wiKTtcbmZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsLCBiYXNlKSB7XG4gICAgY29uc3QgZ2xvYmFsQmFzZSA9IG5ldyBVUkwodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKSk7XG4gICAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlO1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBzZWFyY2hQYXJhbXMgLCBzZWFyY2ggLCBoYXNoICwgaHJlZiAsIG9yaWdpbiAgfSA9IG5ldyBVUkwodXJsLCByZXNvbHZlZEJhc2UpO1xuICAgIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCwgcm91dGVyIHJlY2VpdmVkICR7dXJsfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnk6ICgwLCBfcXVlcnlzdHJpbmcpLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aClcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1yZWxhdGl2ZS11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGFyc2VSZWxhdGl2ZVVybCIsIl91dGlscyIsInJlcXVpcmUiLCJfcXVlcnlzdHJpbmciLCJ1cmwiLCJiYXNlIiwiZ2xvYmFsQmFzZSIsIlVSTCIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWRCYXNlIiwicGF0aG5hbWUiLCJzZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJoYXNoIiwiaHJlZiIsIm9yaWdpbiIsIkVycm9yIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5Iiwic2xpY2UiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n        for(var i = 0, arr2 = new Array(arr.length); i < arr.length; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    }\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n        }));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.formatWithValidation = formatWithValidation;\nexports.HtmlContext = exports.ST = exports.SP = exports.urlObjectKeys = void 0;\nvar _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963\");\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _toConsumableArray(args));\n        }\n        return result;\n    };\n}\nfunction getLocationOrigin() {\n    var _location = window.location, protocol = _location.protocol, hostname = _location.hostname, port = _location.port;\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(port ? ':' + port : '');\n}\nfunction getURL() {\n    var href = window.location.href;\n    var origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    var urlParts = url.split('?');\n    var urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\".concat(urlParts.slice(1).join('?')) : '');\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(App, ctx) {\n        var ref, message, res, props, message1;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (false) {}\n                    ;\n                    if (!((ref = App.prototype) === null || ref === void 0 ? void 0 : ref.getInitialProps)) {\n                        _ctx.next = 5;\n                        break;\n                    }\n                    message = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.\");\n                    throw new Error(message);\n                case 5:\n                    res = ctx.res || ctx.ctx && ctx.ctx.res;\n                    if (App.getInitialProps) {\n                        _ctx.next = 13;\n                        break;\n                    }\n                    if (!(ctx.ctx && ctx.Component)) {\n                        _ctx.next = 12;\n                        break;\n                    }\n                    _ctx.next = 10;\n                    return loadGetInitialProps(ctx.Component, ctx.ctx);\n                case 10:\n                    _ctx.t0 = _ctx.sent;\n                    return _ctx.abrupt(\"return\", {\n                        pageProps: _ctx.t0\n                    });\n                case 12:\n                    return _ctx.abrupt(\"return\", {\n                    });\n                case 13:\n                    _ctx.next = 15;\n                    return App.getInitialProps(ctx);\n                case 15:\n                    props = _ctx.sent;\n                    if (!(res && isResSent(res))) {\n                        _ctx.next = 18;\n                        break;\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 18:\n                    if (props) {\n                        _ctx.next = 21;\n                        break;\n                    }\n                    message1 = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" should resolve to an object. But found \\\"\").concat(props, \"\\\" instead.\");\n                    throw new Error(message1);\n                case 21:\n                    if (true) {\n                        if (Object.keys(props).length === 0 && !ctx.ctx) {\n                            console.warn(\"\".concat(getDisplayName(App), \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\"));\n                        }\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 23:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nvar urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes', \n];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach(function(key) {\n                if (urlObjectKeys.indexOf(key) === -1) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \".concat(key));\n                }\n            });\n        }\n    }\n    return (0, _formatUrl).formatUrl(url);\n}\nvar SP = typeof performance !== 'undefined';\nexports.SP = SP;\nvar ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';\nexports.ST = ST;\nvar DecodeError = /*#__PURE__*/ function(Error) {\n    _inherits(DecodeError, Error);\n    function DecodeError() {\n        _classCallCheck(this, DecodeError);\n        return _possibleConstructorReturn(this, _getPrototypeOf(DecodeError).apply(this, arguments));\n    }\n    return DecodeError;\n}(_wrapNativeSuper(Error));\nexports.DecodeError = DecodeError;\nvar HtmlContext = (0, _react).createContext(null);\nexports.HtmlContext = HtmlContext;\nif (true) {\n    HtmlContext.displayName = 'HtmlContext';\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0UsUUFBUTtBQUMzQkYseUJBQXlCLEdBQUdHLGlCQUFpQjtBQUM3Q0gsY0FBYyxHQUFHSSxNQUFNO0FBQ3ZCSixzQkFBc0IsR0FBR0ssY0FBYztBQUN2Q0wsaUJBQWlCLEdBQUdNLFNBQVM7QUFDN0JOLGdDQUFnQyxHQUFHTyx3QkFBd0I7QUFDM0RQLDJCQUEyQixHQUFHUSxtQkFBbUI7QUFDakRSLDRCQUE0QixHQUFHUyxvQkFBb0I7QUFDbkRULG1CQUFtQixHQUFHQSxVQUFVLEdBQUdBLFVBQVUsR0FBR0EscUJBQXFCLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDOUUsR0FBRyxDQUFDYyxVQUFVLEdBQUdDLG1CQUFPLENBQUMsc0dBQTJCO0FBQ3BELEdBQUcsQ0FBQ0MsTUFBTSxHQUFHRCxtQkFBTyxDQUFDLDRDQUFPO1NBQ25CYixRQUFRLENBQUNlLEVBQUUsRUFBRSxDQUFDO0lBQ25CLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLEtBQUs7SUFDaEIsR0FBRyxDQUFDQyxNQUFNO0lBQ1YsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDO3lDQUFSQyxJQUFJO1lBQUpBLElBQUk7O1FBQ1gsRUFBRSxHQUFHRixJQUFJLEVBQUUsQ0FBQztZQUNSQSxJQUFJLEdBQUcsSUFBSTtZQUNYQyxNQUFNLEdBQUdGLEVBQUUsQ0FBRkEsS0FBVyxDQUFYQSxJQUFJ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b2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanM/ZTdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXhlY09uY2UgPSBleGVjT25jZTtcbmV4cG9ydHMuZ2V0TG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbjtcbmV4cG9ydHMuZ2V0VVJMID0gZ2V0VVJMO1xuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xuZXhwb3J0cy5pc1Jlc1NlbnQgPSBpc1Jlc1NlbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyA9IG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcztcbmV4cG9ydHMubG9hZEdldEluaXRpYWxQcm9wcyA9IGxvYWRHZXRJbml0aWFsUHJvcHM7XG5leHBvcnRzLmZvcm1hdFdpdGhWYWxpZGF0aW9uID0gZm9ybWF0V2l0aFZhbGlkYXRpb247XG5leHBvcnRzLkh0bWxDb250ZXh0ID0gZXhwb3J0cy5TVCA9IGV4cG9ydHMuU1AgPSBleHBvcnRzLnVybE9iamVjdEtleXMgPSB2b2lkIDA7XG52YXIgX2Zvcm1hdFVybCA9IHJlcXVpcmUoXCIuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIGV4ZWNPbmNlKGZuKSB7XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgaWYgKCF1c2VkKSB7XG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgLCBob3N0bmFtZSAsIHBvcnQgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YDtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZycgPyBDb21wb25lbnQgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdO1xuICAgIHJldHVybiB1cmxOb1F1ZXJ5Ly8gZmlyc3Qgd2UgcmVwbGFjZSBhbnkgbm9uLWVuY29kZWQgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkXG4gICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC9cXC8rL2csICcvJykgKyAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJyk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSBBcHAucHJvdG90eXBlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKEFwcCl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcbiAgICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtnZXREaXNwbGF5TmFtZShBcHApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgJ2F1dGgnLFxuICAgICdoYXNoJyxcbiAgICAnaG9zdCcsXG4gICAgJ2hvc3RuYW1lJyxcbiAgICAnaHJlZicsXG4gICAgJ3BhdGgnLFxuICAgICdwYXRobmFtZScsXG4gICAgJ3BvcnQnLFxuICAgICdwcm90b2NvbCcsXG4gICAgJ3F1ZXJ5JyxcbiAgICAnc2VhcmNoJyxcbiAgICAnc2xhc2hlcycsIFxuXTtcbmV4cG9ydHMudXJsT2JqZWN0S2V5cyA9IHVybE9iamVjdEtleXM7XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRVcmwodXJsKTtcbn1cbmNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydHMuU1AgPSBTUDtcbmNvbnN0IFNUID0gU1AgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLlNUID0gU1Q7XG5jbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuRGVjb2RlRXJyb3IgPSBEZWNvZGVFcnJvcjtcbmNvbnN0IEh0bWxDb250ZXh0ID0gKDAsIF9yZWFjdCkuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuSHRtbENvbnRleHQgPSBIdG1sQ29udGV4dDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgSHRtbENvbnRleHQuZGlzcGxheU5hbWUgPSAnSHRtbENvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjT25jZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiZ2V0RGlzcGxheU5hbWUiLCJpc1Jlc1NlbnQiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJIdG1sQ29udGV4dCIsIlNUIiwiU1AiLCJ1cmxPYmplY3RLZXlzIiwiX2Zvcm1hdFVybCIsInJlcXVpcmUiLCJfcmVhY3QiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsIiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwicmVmIiwibWVzc2FnZSIsInByb3BzIiwicHJvdG90eXBlIiwiZ2V0SW5pdGlhbFByb3BzIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJrZXlzIiwiY29uc29sZSIsIndhcm4iLCJmb3JFYWNoIiwia2V5IiwiaW5kZXhPZiIsImZvcm1hdFVybCIsInBlcmZvcm1hbmNlIiwibWFyayIsIm1lYXN1cmUiLCJEZWNvZGVFcnJvciIsImNyZWF0ZUNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n");

/***/ })

});